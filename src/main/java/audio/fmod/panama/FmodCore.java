// Generated by jextract

package audio.fmod.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class FmodCore extends FmodCore_1 {

    FmodCore() {
        // Should not be called directly
    }

    private static class FMOD_Channel_GetDSPIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetDSPIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetDSPIndex(FMOD_CHANNEL *channel, FMOD_DSP *dsp, int *index)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetDSPIndex$descriptor() {
        return FMOD_Channel_GetDSPIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetDSPIndex(FMOD_CHANNEL *channel, FMOD_DSP *dsp, int *index)
     * }
     */
    public static MethodHandle FMOD_Channel_GetDSPIndex$handle() {
        return FMOD_Channel_GetDSPIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetDSPIndex(FMOD_CHANNEL *channel, FMOD_DSP *dsp, int *index)
     * }
     */
    public static MemorySegment FMOD_Channel_GetDSPIndex$address() {
        return FMOD_Channel_GetDSPIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetDSPIndex(FMOD_CHANNEL *channel, FMOD_DSP *dsp, int *index)
     * }
     */
    public static int FMOD_Channel_GetDSPIndex(MemorySegment channel, MemorySegment dsp, MemorySegment index) {
        var mh$ = FMOD_Channel_GetDSPIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetDSPIndex", channel, dsp, index);
            }
            return (int)mh$.invokeExact(channel, dsp, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DAttributes(FMOD_CHANNEL *channel, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DAttributes$descriptor() {
        return FMOD_Channel_Set3DAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DAttributes(FMOD_CHANNEL *channel, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DAttributes$handle() {
        return FMOD_Channel_Set3DAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DAttributes(FMOD_CHANNEL *channel, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DAttributes$address() {
        return FMOD_Channel_Set3DAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DAttributes(FMOD_CHANNEL *channel, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static int FMOD_Channel_Set3DAttributes(MemorySegment channel, MemorySegment pos, MemorySegment vel) {
        var mh$ = FMOD_Channel_Set3DAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DAttributes", channel, pos, vel);
            }
            return (int)mh$.invokeExact(channel, pos, vel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DAttributes(FMOD_CHANNEL *channel, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DAttributes$descriptor() {
        return FMOD_Channel_Get3DAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DAttributes(FMOD_CHANNEL *channel, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DAttributes$handle() {
        return FMOD_Channel_Get3DAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DAttributes(FMOD_CHANNEL *channel, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DAttributes$address() {
        return FMOD_Channel_Get3DAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DAttributes(FMOD_CHANNEL *channel, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static int FMOD_Channel_Get3DAttributes(MemorySegment channel, MemorySegment pos, MemorySegment vel) {
        var mh$ = FMOD_Channel_Get3DAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DAttributes", channel, pos, vel);
            }
            return (int)mh$.invokeExact(channel, pos, vel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DMinMaxDistance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DMinMaxDistance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DMinMaxDistance(FMOD_CHANNEL *channel, float mindistance, float maxdistance)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DMinMaxDistance$descriptor() {
        return FMOD_Channel_Set3DMinMaxDistance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DMinMaxDistance(FMOD_CHANNEL *channel, float mindistance, float maxdistance)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DMinMaxDistance$handle() {
        return FMOD_Channel_Set3DMinMaxDistance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DMinMaxDistance(FMOD_CHANNEL *channel, float mindistance, float maxdistance)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DMinMaxDistance$address() {
        return FMOD_Channel_Set3DMinMaxDistance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DMinMaxDistance(FMOD_CHANNEL *channel, float mindistance, float maxdistance)
     * }
     */
    public static int FMOD_Channel_Set3DMinMaxDistance(MemorySegment channel, float mindistance, float maxdistance) {
        var mh$ = FMOD_Channel_Set3DMinMaxDistance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DMinMaxDistance", channel, mindistance, maxdistance);
            }
            return (int)mh$.invokeExact(channel, mindistance, maxdistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DMinMaxDistance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DMinMaxDistance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DMinMaxDistance(FMOD_CHANNEL *channel, float *mindistance, float *maxdistance)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DMinMaxDistance$descriptor() {
        return FMOD_Channel_Get3DMinMaxDistance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DMinMaxDistance(FMOD_CHANNEL *channel, float *mindistance, float *maxdistance)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DMinMaxDistance$handle() {
        return FMOD_Channel_Get3DMinMaxDistance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DMinMaxDistance(FMOD_CHANNEL *channel, float *mindistance, float *maxdistance)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DMinMaxDistance$address() {
        return FMOD_Channel_Get3DMinMaxDistance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DMinMaxDistance(FMOD_CHANNEL *channel, float *mindistance, float *maxdistance)
     * }
     */
    public static int FMOD_Channel_Get3DMinMaxDistance(MemorySegment channel, MemorySegment mindistance, MemorySegment maxdistance) {
        var mh$ = FMOD_Channel_Get3DMinMaxDistance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DMinMaxDistance", channel, mindistance, maxdistance);
            }
            return (int)mh$.invokeExact(channel, mindistance, maxdistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DConeSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DConeSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeSettings(FMOD_CHANNEL *channel, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DConeSettings$descriptor() {
        return FMOD_Channel_Set3DConeSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeSettings(FMOD_CHANNEL *channel, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DConeSettings$handle() {
        return FMOD_Channel_Set3DConeSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeSettings(FMOD_CHANNEL *channel, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DConeSettings$address() {
        return FMOD_Channel_Set3DConeSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeSettings(FMOD_CHANNEL *channel, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static int FMOD_Channel_Set3DConeSettings(MemorySegment channel, float insideconeangle, float outsideconeangle, float outsidevolume) {
        var mh$ = FMOD_Channel_Set3DConeSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DConeSettings", channel, insideconeangle, outsideconeangle, outsidevolume);
            }
            return (int)mh$.invokeExact(channel, insideconeangle, outsideconeangle, outsidevolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DConeSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DConeSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeSettings(FMOD_CHANNEL *channel, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DConeSettings$descriptor() {
        return FMOD_Channel_Get3DConeSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeSettings(FMOD_CHANNEL *channel, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DConeSettings$handle() {
        return FMOD_Channel_Get3DConeSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeSettings(FMOD_CHANNEL *channel, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DConeSettings$address() {
        return FMOD_Channel_Get3DConeSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeSettings(FMOD_CHANNEL *channel, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static int FMOD_Channel_Get3DConeSettings(MemorySegment channel, MemorySegment insideconeangle, MemorySegment outsideconeangle, MemorySegment outsidevolume) {
        var mh$ = FMOD_Channel_Get3DConeSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DConeSettings", channel, insideconeangle, outsideconeangle, outsidevolume);
            }
            return (int)mh$.invokeExact(channel, insideconeangle, outsideconeangle, outsidevolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DConeOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DConeOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DConeOrientation$descriptor() {
        return FMOD_Channel_Set3DConeOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DConeOrientation$handle() {
        return FMOD_Channel_Set3DConeOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DConeOrientation$address() {
        return FMOD_Channel_Set3DConeOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static int FMOD_Channel_Set3DConeOrientation(MemorySegment channel, MemorySegment orientation) {
        var mh$ = FMOD_Channel_Set3DConeOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DConeOrientation", channel, orientation);
            }
            return (int)mh$.invokeExact(channel, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DConeOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DConeOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DConeOrientation$descriptor() {
        return FMOD_Channel_Get3DConeOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DConeOrientation$handle() {
        return FMOD_Channel_Get3DConeOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DConeOrientation$address() {
        return FMOD_Channel_Get3DConeOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DConeOrientation(FMOD_CHANNEL *channel, FMOD_VECTOR *orientation)
     * }
     */
    public static int FMOD_Channel_Get3DConeOrientation(MemorySegment channel, MemorySegment orientation) {
        var mh$ = FMOD_Channel_Get3DConeOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DConeOrientation", channel, orientation);
            }
            return (int)mh$.invokeExact(channel, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DCustomRolloff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DCustomRolloff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DCustomRolloff$descriptor() {
        return FMOD_Channel_Set3DCustomRolloff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DCustomRolloff$handle() {
        return FMOD_Channel_Set3DCustomRolloff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DCustomRolloff$address() {
        return FMOD_Channel_Set3DCustomRolloff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static int FMOD_Channel_Set3DCustomRolloff(MemorySegment channel, MemorySegment points, int numpoints) {
        var mh$ = FMOD_Channel_Set3DCustomRolloff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DCustomRolloff", channel, points, numpoints);
            }
            return (int)mh$.invokeExact(channel, points, numpoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DCustomRolloff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DCustomRolloff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DCustomRolloff$descriptor() {
        return FMOD_Channel_Get3DCustomRolloff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DCustomRolloff$handle() {
        return FMOD_Channel_Get3DCustomRolloff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DCustomRolloff$address() {
        return FMOD_Channel_Get3DCustomRolloff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DCustomRolloff(FMOD_CHANNEL *channel, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static int FMOD_Channel_Get3DCustomRolloff(MemorySegment channel, MemorySegment points, MemorySegment numpoints) {
        var mh$ = FMOD_Channel_Get3DCustomRolloff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DCustomRolloff", channel, points, numpoints);
            }
            return (int)mh$.invokeExact(channel, points, numpoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DOcclusion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DOcclusion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DOcclusion(FMOD_CHANNEL *channel, float directocclusion, float reverbocclusion)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DOcclusion$descriptor() {
        return FMOD_Channel_Set3DOcclusion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DOcclusion(FMOD_CHANNEL *channel, float directocclusion, float reverbocclusion)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DOcclusion$handle() {
        return FMOD_Channel_Set3DOcclusion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DOcclusion(FMOD_CHANNEL *channel, float directocclusion, float reverbocclusion)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DOcclusion$address() {
        return FMOD_Channel_Set3DOcclusion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DOcclusion(FMOD_CHANNEL *channel, float directocclusion, float reverbocclusion)
     * }
     */
    public static int FMOD_Channel_Set3DOcclusion(MemorySegment channel, float directocclusion, float reverbocclusion) {
        var mh$ = FMOD_Channel_Set3DOcclusion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DOcclusion", channel, directocclusion, reverbocclusion);
            }
            return (int)mh$.invokeExact(channel, directocclusion, reverbocclusion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DOcclusion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DOcclusion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DOcclusion(FMOD_CHANNEL *channel, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DOcclusion$descriptor() {
        return FMOD_Channel_Get3DOcclusion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DOcclusion(FMOD_CHANNEL *channel, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DOcclusion$handle() {
        return FMOD_Channel_Get3DOcclusion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DOcclusion(FMOD_CHANNEL *channel, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DOcclusion$address() {
        return FMOD_Channel_Get3DOcclusion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DOcclusion(FMOD_CHANNEL *channel, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static int FMOD_Channel_Get3DOcclusion(MemorySegment channel, MemorySegment directocclusion, MemorySegment reverbocclusion) {
        var mh$ = FMOD_Channel_Get3DOcclusion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DOcclusion", channel, directocclusion, reverbocclusion);
            }
            return (int)mh$.invokeExact(channel, directocclusion, reverbocclusion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DSpread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DSpread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DSpread(FMOD_CHANNEL *channel, float angle)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DSpread$descriptor() {
        return FMOD_Channel_Set3DSpread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DSpread(FMOD_CHANNEL *channel, float angle)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DSpread$handle() {
        return FMOD_Channel_Set3DSpread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DSpread(FMOD_CHANNEL *channel, float angle)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DSpread$address() {
        return FMOD_Channel_Set3DSpread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DSpread(FMOD_CHANNEL *channel, float angle)
     * }
     */
    public static int FMOD_Channel_Set3DSpread(MemorySegment channel, float angle) {
        var mh$ = FMOD_Channel_Set3DSpread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DSpread", channel, angle);
            }
            return (int)mh$.invokeExact(channel, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DSpread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DSpread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DSpread(FMOD_CHANNEL *channel, float *angle)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DSpread$descriptor() {
        return FMOD_Channel_Get3DSpread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DSpread(FMOD_CHANNEL *channel, float *angle)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DSpread$handle() {
        return FMOD_Channel_Get3DSpread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DSpread(FMOD_CHANNEL *channel, float *angle)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DSpread$address() {
        return FMOD_Channel_Get3DSpread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DSpread(FMOD_CHANNEL *channel, float *angle)
     * }
     */
    public static int FMOD_Channel_Get3DSpread(MemorySegment channel, MemorySegment angle) {
        var mh$ = FMOD_Channel_Get3DSpread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DSpread", channel, angle);
            }
            return (int)mh$.invokeExact(channel, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DLevel$descriptor() {
        return FMOD_Channel_Set3DLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DLevel$handle() {
        return FMOD_Channel_Set3DLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DLevel$address() {
        return FMOD_Channel_Set3DLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static int FMOD_Channel_Set3DLevel(MemorySegment channel, float level) {
        var mh$ = FMOD_Channel_Set3DLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DLevel", channel, level);
            }
            return (int)mh$.invokeExact(channel, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DLevel$descriptor() {
        return FMOD_Channel_Get3DLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DLevel$handle() {
        return FMOD_Channel_Get3DLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DLevel$address() {
        return FMOD_Channel_Get3DLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static int FMOD_Channel_Get3DLevel(MemorySegment channel, MemorySegment level) {
        var mh$ = FMOD_Channel_Get3DLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DLevel", channel, level);
            }
            return (int)mh$.invokeExact(channel, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DDopplerLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DDopplerLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDopplerLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DDopplerLevel$descriptor() {
        return FMOD_Channel_Set3DDopplerLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDopplerLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DDopplerLevel$handle() {
        return FMOD_Channel_Set3DDopplerLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDopplerLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DDopplerLevel$address() {
        return FMOD_Channel_Set3DDopplerLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDopplerLevel(FMOD_CHANNEL *channel, float level)
     * }
     */
    public static int FMOD_Channel_Set3DDopplerLevel(MemorySegment channel, float level) {
        var mh$ = FMOD_Channel_Set3DDopplerLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DDopplerLevel", channel, level);
            }
            return (int)mh$.invokeExact(channel, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DDopplerLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DDopplerLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDopplerLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DDopplerLevel$descriptor() {
        return FMOD_Channel_Get3DDopplerLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDopplerLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DDopplerLevel$handle() {
        return FMOD_Channel_Get3DDopplerLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDopplerLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DDopplerLevel$address() {
        return FMOD_Channel_Get3DDopplerLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDopplerLevel(FMOD_CHANNEL *channel, float *level)
     * }
     */
    public static int FMOD_Channel_Get3DDopplerLevel(MemorySegment channel, MemorySegment level) {
        var mh$ = FMOD_Channel_Get3DDopplerLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DDopplerLevel", channel, level);
            }
            return (int)mh$.invokeExact(channel, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Set3DDistanceFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Set3DDistanceFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Set3DDistanceFilter$descriptor() {
        return FMOD_Channel_Set3DDistanceFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static MethodHandle FMOD_Channel_Set3DDistanceFilter$handle() {
        return FMOD_Channel_Set3DDistanceFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static MemorySegment FMOD_Channel_Set3DDistanceFilter$address() {
        return FMOD_Channel_Set3DDistanceFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Set3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static int FMOD_Channel_Set3DDistanceFilter(MemorySegment channel, int custom, float customLevel, float centerFreq) {
        var mh$ = FMOD_Channel_Set3DDistanceFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Set3DDistanceFilter", channel, custom, customLevel, centerFreq);
            }
            return (int)mh$.invokeExact(channel, custom, customLevel, centerFreq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_Get3DDistanceFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_Get3DDistanceFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_Get3DDistanceFilter$descriptor() {
        return FMOD_Channel_Get3DDistanceFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static MethodHandle FMOD_Channel_Get3DDistanceFilter$handle() {
        return FMOD_Channel_Get3DDistanceFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static MemorySegment FMOD_Channel_Get3DDistanceFilter$address() {
        return FMOD_Channel_Get3DDistanceFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_Get3DDistanceFilter(FMOD_CHANNEL *channel, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static int FMOD_Channel_Get3DDistanceFilter(MemorySegment channel, MemorySegment custom, MemorySegment customLevel, MemorySegment centerFreq) {
        var mh$ = FMOD_Channel_Get3DDistanceFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_Get3DDistanceFilter", channel, custom, customLevel, centerFreq);
            }
            return (int)mh$.invokeExact(channel, custom, customLevel, centerFreq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetUserData(FMOD_CHANNEL *channel, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetUserData$descriptor() {
        return FMOD_Channel_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetUserData(FMOD_CHANNEL *channel, void *userdata)
     * }
     */
    public static MethodHandle FMOD_Channel_SetUserData$handle() {
        return FMOD_Channel_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetUserData(FMOD_CHANNEL *channel, void *userdata)
     * }
     */
    public static MemorySegment FMOD_Channel_SetUserData$address() {
        return FMOD_Channel_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetUserData(FMOD_CHANNEL *channel, void *userdata)
     * }
     */
    public static int FMOD_Channel_SetUserData(MemorySegment channel, MemorySegment userdata) {
        var mh$ = FMOD_Channel_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetUserData", channel, userdata);
            }
            return (int)mh$.invokeExact(channel, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetUserData(FMOD_CHANNEL *channel, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetUserData$descriptor() {
        return FMOD_Channel_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetUserData(FMOD_CHANNEL *channel, void **userdata)
     * }
     */
    public static MethodHandle FMOD_Channel_GetUserData$handle() {
        return FMOD_Channel_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetUserData(FMOD_CHANNEL *channel, void **userdata)
     * }
     */
    public static MemorySegment FMOD_Channel_GetUserData$address() {
        return FMOD_Channel_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetUserData(FMOD_CHANNEL *channel, void **userdata)
     * }
     */
    public static int FMOD_Channel_GetUserData(MemorySegment channel, MemorySegment userdata) {
        var mh$ = FMOD_Channel_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetUserData", channel, userdata);
            }
            return (int)mh$.invokeExact(channel, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetFrequency(FMOD_CHANNEL *channel, float frequency)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetFrequency$descriptor() {
        return FMOD_Channel_SetFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetFrequency(FMOD_CHANNEL *channel, float frequency)
     * }
     */
    public static MethodHandle FMOD_Channel_SetFrequency$handle() {
        return FMOD_Channel_SetFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetFrequency(FMOD_CHANNEL *channel, float frequency)
     * }
     */
    public static MemorySegment FMOD_Channel_SetFrequency$address() {
        return FMOD_Channel_SetFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetFrequency(FMOD_CHANNEL *channel, float frequency)
     * }
     */
    public static int FMOD_Channel_SetFrequency(MemorySegment channel, float frequency) {
        var mh$ = FMOD_Channel_SetFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetFrequency", channel, frequency);
            }
            return (int)mh$.invokeExact(channel, frequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetFrequency(FMOD_CHANNEL *channel, float *frequency)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetFrequency$descriptor() {
        return FMOD_Channel_GetFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetFrequency(FMOD_CHANNEL *channel, float *frequency)
     * }
     */
    public static MethodHandle FMOD_Channel_GetFrequency$handle() {
        return FMOD_Channel_GetFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetFrequency(FMOD_CHANNEL *channel, float *frequency)
     * }
     */
    public static MemorySegment FMOD_Channel_GetFrequency$address() {
        return FMOD_Channel_GetFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetFrequency(FMOD_CHANNEL *channel, float *frequency)
     * }
     */
    public static int FMOD_Channel_GetFrequency(MemorySegment channel, MemorySegment frequency) {
        var mh$ = FMOD_Channel_GetFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetFrequency", channel, frequency);
            }
            return (int)mh$.invokeExact(channel, frequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPriority(FMOD_CHANNEL *channel, int priority)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetPriority$descriptor() {
        return FMOD_Channel_SetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPriority(FMOD_CHANNEL *channel, int priority)
     * }
     */
    public static MethodHandle FMOD_Channel_SetPriority$handle() {
        return FMOD_Channel_SetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPriority(FMOD_CHANNEL *channel, int priority)
     * }
     */
    public static MemorySegment FMOD_Channel_SetPriority$address() {
        return FMOD_Channel_SetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPriority(FMOD_CHANNEL *channel, int priority)
     * }
     */
    public static int FMOD_Channel_SetPriority(MemorySegment channel, int priority) {
        var mh$ = FMOD_Channel_SetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetPriority", channel, priority);
            }
            return (int)mh$.invokeExact(channel, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPriority(FMOD_CHANNEL *channel, int *priority)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetPriority$descriptor() {
        return FMOD_Channel_GetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPriority(FMOD_CHANNEL *channel, int *priority)
     * }
     */
    public static MethodHandle FMOD_Channel_GetPriority$handle() {
        return FMOD_Channel_GetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPriority(FMOD_CHANNEL *channel, int *priority)
     * }
     */
    public static MemorySegment FMOD_Channel_GetPriority$address() {
        return FMOD_Channel_GetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPriority(FMOD_CHANNEL *channel, int *priority)
     * }
     */
    public static int FMOD_Channel_GetPriority(MemorySegment channel, MemorySegment priority) {
        var mh$ = FMOD_Channel_GetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetPriority", channel, priority);
            }
            return (int)mh$.invokeExact(channel, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPosition(FMOD_CHANNEL *channel, unsigned int position, FMOD_TIMEUNIT postype)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetPosition$descriptor() {
        return FMOD_Channel_SetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPosition(FMOD_CHANNEL *channel, unsigned int position, FMOD_TIMEUNIT postype)
     * }
     */
    public static MethodHandle FMOD_Channel_SetPosition$handle() {
        return FMOD_Channel_SetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPosition(FMOD_CHANNEL *channel, unsigned int position, FMOD_TIMEUNIT postype)
     * }
     */
    public static MemorySegment FMOD_Channel_SetPosition$address() {
        return FMOD_Channel_SetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetPosition(FMOD_CHANNEL *channel, unsigned int position, FMOD_TIMEUNIT postype)
     * }
     */
    public static int FMOD_Channel_SetPosition(MemorySegment channel, int position, int postype) {
        var mh$ = FMOD_Channel_SetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetPosition", channel, position, postype);
            }
            return (int)mh$.invokeExact(channel, position, postype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPosition(FMOD_CHANNEL *channel, unsigned int *position, FMOD_TIMEUNIT postype)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetPosition$descriptor() {
        return FMOD_Channel_GetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPosition(FMOD_CHANNEL *channel, unsigned int *position, FMOD_TIMEUNIT postype)
     * }
     */
    public static MethodHandle FMOD_Channel_GetPosition$handle() {
        return FMOD_Channel_GetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPosition(FMOD_CHANNEL *channel, unsigned int *position, FMOD_TIMEUNIT postype)
     * }
     */
    public static MemorySegment FMOD_Channel_GetPosition$address() {
        return FMOD_Channel_GetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetPosition(FMOD_CHANNEL *channel, unsigned int *position, FMOD_TIMEUNIT postype)
     * }
     */
    public static int FMOD_Channel_GetPosition(MemorySegment channel, MemorySegment position, int postype) {
        var mh$ = FMOD_Channel_GetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetPosition", channel, position, postype);
            }
            return (int)mh$.invokeExact(channel, position, postype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetChannelGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetChannelGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetChannelGroup$descriptor() {
        return FMOD_Channel_SetChannelGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static MethodHandle FMOD_Channel_SetChannelGroup$handle() {
        return FMOD_Channel_SetChannelGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static MemorySegment FMOD_Channel_SetChannelGroup$address() {
        return FMOD_Channel_SetChannelGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static int FMOD_Channel_SetChannelGroup(MemorySegment channel, MemorySegment channelgroup) {
        var mh$ = FMOD_Channel_SetChannelGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetChannelGroup", channel, channelgroup);
            }
            return (int)mh$.invokeExact(channel, channelgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetChannelGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetChannelGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP **channelgroup)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetChannelGroup$descriptor() {
        return FMOD_Channel_GetChannelGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP **channelgroup)
     * }
     */
    public static MethodHandle FMOD_Channel_GetChannelGroup$handle() {
        return FMOD_Channel_GetChannelGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP **channelgroup)
     * }
     */
    public static MemorySegment FMOD_Channel_GetChannelGroup$address() {
        return FMOD_Channel_GetChannelGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetChannelGroup(FMOD_CHANNEL *channel, FMOD_CHANNELGROUP **channelgroup)
     * }
     */
    public static int FMOD_Channel_GetChannelGroup(MemorySegment channel, MemorySegment channelgroup) {
        var mh$ = FMOD_Channel_GetChannelGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetChannelGroup", channel, channelgroup);
            }
            return (int)mh$.invokeExact(channel, channelgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetLoopCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetLoopCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopCount(FMOD_CHANNEL *channel, int loopcount)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetLoopCount$descriptor() {
        return FMOD_Channel_SetLoopCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopCount(FMOD_CHANNEL *channel, int loopcount)
     * }
     */
    public static MethodHandle FMOD_Channel_SetLoopCount$handle() {
        return FMOD_Channel_SetLoopCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopCount(FMOD_CHANNEL *channel, int loopcount)
     * }
     */
    public static MemorySegment FMOD_Channel_SetLoopCount$address() {
        return FMOD_Channel_SetLoopCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopCount(FMOD_CHANNEL *channel, int loopcount)
     * }
     */
    public static int FMOD_Channel_SetLoopCount(MemorySegment channel, int loopcount) {
        var mh$ = FMOD_Channel_SetLoopCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetLoopCount", channel, loopcount);
            }
            return (int)mh$.invokeExact(channel, loopcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetLoopCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetLoopCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopCount(FMOD_CHANNEL *channel, int *loopcount)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetLoopCount$descriptor() {
        return FMOD_Channel_GetLoopCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopCount(FMOD_CHANNEL *channel, int *loopcount)
     * }
     */
    public static MethodHandle FMOD_Channel_GetLoopCount$handle() {
        return FMOD_Channel_GetLoopCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopCount(FMOD_CHANNEL *channel, int *loopcount)
     * }
     */
    public static MemorySegment FMOD_Channel_GetLoopCount$address() {
        return FMOD_Channel_GetLoopCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopCount(FMOD_CHANNEL *channel, int *loopcount)
     * }
     */
    public static int FMOD_Channel_GetLoopCount(MemorySegment channel, MemorySegment loopcount) {
        var mh$ = FMOD_Channel_GetLoopCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetLoopCount", channel, loopcount);
            }
            return (int)mh$.invokeExact(channel, loopcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_SetLoopPoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_SetLoopPoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopPoints(FMOD_CHANNEL *channel, unsigned int loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_SetLoopPoints$descriptor() {
        return FMOD_Channel_SetLoopPoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopPoints(FMOD_CHANNEL *channel, unsigned int loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static MethodHandle FMOD_Channel_SetLoopPoints$handle() {
        return FMOD_Channel_SetLoopPoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopPoints(FMOD_CHANNEL *channel, unsigned int loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static MemorySegment FMOD_Channel_SetLoopPoints$address() {
        return FMOD_Channel_SetLoopPoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_SetLoopPoints(FMOD_CHANNEL *channel, unsigned int loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static int FMOD_Channel_SetLoopPoints(MemorySegment channel, int loopstart, int loopstarttype, int loopend, int loopendtype) {
        var mh$ = FMOD_Channel_SetLoopPoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_SetLoopPoints", channel, loopstart, loopstarttype, loopend, loopendtype);
            }
            return (int)mh$.invokeExact(channel, loopstart, loopstarttype, loopend, loopendtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetLoopPoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetLoopPoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopPoints(FMOD_CHANNEL *channel, unsigned int *loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int *loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetLoopPoints$descriptor() {
        return FMOD_Channel_GetLoopPoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopPoints(FMOD_CHANNEL *channel, unsigned int *loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int *loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static MethodHandle FMOD_Channel_GetLoopPoints$handle() {
        return FMOD_Channel_GetLoopPoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopPoints(FMOD_CHANNEL *channel, unsigned int *loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int *loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static MemorySegment FMOD_Channel_GetLoopPoints$address() {
        return FMOD_Channel_GetLoopPoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetLoopPoints(FMOD_CHANNEL *channel, unsigned int *loopstart, FMOD_TIMEUNIT loopstarttype, unsigned int *loopend, FMOD_TIMEUNIT loopendtype)
     * }
     */
    public static int FMOD_Channel_GetLoopPoints(MemorySegment channel, MemorySegment loopstart, int loopstarttype, MemorySegment loopend, int loopendtype) {
        var mh$ = FMOD_Channel_GetLoopPoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetLoopPoints", channel, loopstart, loopstarttype, loopend, loopendtype);
            }
            return (int)mh$.invokeExact(channel, loopstart, loopstarttype, loopend, loopendtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_IsVirtual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_IsVirtual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_IsVirtual(FMOD_CHANNEL *channel, FMOD_BOOL *isvirtual)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_IsVirtual$descriptor() {
        return FMOD_Channel_IsVirtual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_IsVirtual(FMOD_CHANNEL *channel, FMOD_BOOL *isvirtual)
     * }
     */
    public static MethodHandle FMOD_Channel_IsVirtual$handle() {
        return FMOD_Channel_IsVirtual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_IsVirtual(FMOD_CHANNEL *channel, FMOD_BOOL *isvirtual)
     * }
     */
    public static MemorySegment FMOD_Channel_IsVirtual$address() {
        return FMOD_Channel_IsVirtual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_IsVirtual(FMOD_CHANNEL *channel, FMOD_BOOL *isvirtual)
     * }
     */
    public static int FMOD_Channel_IsVirtual(MemorySegment channel, MemorySegment isvirtual) {
        var mh$ = FMOD_Channel_IsVirtual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_IsVirtual", channel, isvirtual);
            }
            return (int)mh$.invokeExact(channel, isvirtual);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetCurrentSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetCurrentSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetCurrentSound(FMOD_CHANNEL *channel, FMOD_SOUND **sound)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetCurrentSound$descriptor() {
        return FMOD_Channel_GetCurrentSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetCurrentSound(FMOD_CHANNEL *channel, FMOD_SOUND **sound)
     * }
     */
    public static MethodHandle FMOD_Channel_GetCurrentSound$handle() {
        return FMOD_Channel_GetCurrentSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetCurrentSound(FMOD_CHANNEL *channel, FMOD_SOUND **sound)
     * }
     */
    public static MemorySegment FMOD_Channel_GetCurrentSound$address() {
        return FMOD_Channel_GetCurrentSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetCurrentSound(FMOD_CHANNEL *channel, FMOD_SOUND **sound)
     * }
     */
    public static int FMOD_Channel_GetCurrentSound(MemorySegment channel, MemorySegment sound) {
        var mh$ = FMOD_Channel_GetCurrentSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetCurrentSound", channel, sound);
            }
            return (int)mh$.invokeExact(channel, sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Channel_GetIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Channel_GetIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetIndex(FMOD_CHANNEL *channel, int *index)
     * }
     */
    public static FunctionDescriptor FMOD_Channel_GetIndex$descriptor() {
        return FMOD_Channel_GetIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetIndex(FMOD_CHANNEL *channel, int *index)
     * }
     */
    public static MethodHandle FMOD_Channel_GetIndex$handle() {
        return FMOD_Channel_GetIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetIndex(FMOD_CHANNEL *channel, int *index)
     * }
     */
    public static MemorySegment FMOD_Channel_GetIndex$address() {
        return FMOD_Channel_GetIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Channel_GetIndex(FMOD_CHANNEL *channel, int *index)
     * }
     */
    public static int FMOD_Channel_GetIndex(MemorySegment channel, MemorySegment index) {
        var mh$ = FMOD_Channel_GetIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Channel_GetIndex", channel, index);
            }
            return (int)mh$.invokeExact(channel, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetSystemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetSystemObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetSystemObject(FMOD_CHANNELGROUP *channelgroup, FMOD_SYSTEM **system)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetSystemObject$descriptor() {
        return FMOD_ChannelGroup_GetSystemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetSystemObject(FMOD_CHANNELGROUP *channelgroup, FMOD_SYSTEM **system)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetSystemObject$handle() {
        return FMOD_ChannelGroup_GetSystemObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetSystemObject(FMOD_CHANNELGROUP *channelgroup, FMOD_SYSTEM **system)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetSystemObject$address() {
        return FMOD_ChannelGroup_GetSystemObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetSystemObject(FMOD_CHANNELGROUP *channelgroup, FMOD_SYSTEM **system)
     * }
     */
    public static int FMOD_ChannelGroup_GetSystemObject(MemorySegment channelgroup, MemorySegment system) {
        var mh$ = FMOD_ChannelGroup_GetSystemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetSystemObject", channelgroup, system);
            }
            return (int)mh$.invokeExact(channelgroup, system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Stop(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Stop$descriptor() {
        return FMOD_ChannelGroup_Stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Stop(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Stop$handle() {
        return FMOD_ChannelGroup_Stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Stop(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Stop$address() {
        return FMOD_ChannelGroup_Stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Stop(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static int FMOD_ChannelGroup_Stop(MemorySegment channelgroup) {
        var mh$ = FMOD_ChannelGroup_Stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Stop", channelgroup);
            }
            return (int)mh$.invokeExact(channelgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetPaused {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetPaused");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL paused)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetPaused$descriptor() {
        return FMOD_ChannelGroup_SetPaused.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL paused)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetPaused$handle() {
        return FMOD_ChannelGroup_SetPaused.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL paused)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetPaused$address() {
        return FMOD_ChannelGroup_SetPaused.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL paused)
     * }
     */
    public static int FMOD_ChannelGroup_SetPaused(MemorySegment channelgroup, int paused) {
        var mh$ = FMOD_ChannelGroup_SetPaused.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetPaused", channelgroup, paused);
            }
            return (int)mh$.invokeExact(channelgroup, paused);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetPaused {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetPaused");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *paused)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetPaused$descriptor() {
        return FMOD_ChannelGroup_GetPaused.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *paused)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetPaused$handle() {
        return FMOD_ChannelGroup_GetPaused.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *paused)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetPaused$address() {
        return FMOD_ChannelGroup_GetPaused.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPaused(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *paused)
     * }
     */
    public static int FMOD_ChannelGroup_GetPaused(MemorySegment channelgroup, MemorySegment paused) {
        var mh$ = FMOD_ChannelGroup_GetPaused.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetPaused", channelgroup, paused);
            }
            return (int)mh$.invokeExact(channelgroup, paused);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolume(FMOD_CHANNELGROUP *channelgroup, float volume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetVolume$descriptor() {
        return FMOD_ChannelGroup_SetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolume(FMOD_CHANNELGROUP *channelgroup, float volume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetVolume$handle() {
        return FMOD_ChannelGroup_SetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolume(FMOD_CHANNELGROUP *channelgroup, float volume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetVolume$address() {
        return FMOD_ChannelGroup_SetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolume(FMOD_CHANNELGROUP *channelgroup, float volume)
     * }
     */
    public static int FMOD_ChannelGroup_SetVolume(MemorySegment channelgroup, float volume) {
        var mh$ = FMOD_ChannelGroup_SetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetVolume", channelgroup, volume);
            }
            return (int)mh$.invokeExact(channelgroup, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolume(FMOD_CHANNELGROUP *channelgroup, float *volume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetVolume$descriptor() {
        return FMOD_ChannelGroup_GetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolume(FMOD_CHANNELGROUP *channelgroup, float *volume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetVolume$handle() {
        return FMOD_ChannelGroup_GetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolume(FMOD_CHANNELGROUP *channelgroup, float *volume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetVolume$address() {
        return FMOD_ChannelGroup_GetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolume(FMOD_CHANNELGROUP *channelgroup, float *volume)
     * }
     */
    public static int FMOD_ChannelGroup_GetVolume(MemorySegment channelgroup, MemorySegment volume) {
        var mh$ = FMOD_ChannelGroup_GetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetVolume", channelgroup, volume);
            }
            return (int)mh$.invokeExact(channelgroup, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetVolumeRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetVolumeRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL ramp)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetVolumeRamp$descriptor() {
        return FMOD_ChannelGroup_SetVolumeRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL ramp)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetVolumeRamp$handle() {
        return FMOD_ChannelGroup_SetVolumeRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL ramp)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetVolumeRamp$address() {
        return FMOD_ChannelGroup_SetVolumeRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL ramp)
     * }
     */
    public static int FMOD_ChannelGroup_SetVolumeRamp(MemorySegment channelgroup, int ramp) {
        var mh$ = FMOD_ChannelGroup_SetVolumeRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetVolumeRamp", channelgroup, ramp);
            }
            return (int)mh$.invokeExact(channelgroup, ramp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetVolumeRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetVolumeRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *ramp)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetVolumeRamp$descriptor() {
        return FMOD_ChannelGroup_GetVolumeRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *ramp)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetVolumeRamp$handle() {
        return FMOD_ChannelGroup_GetVolumeRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *ramp)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetVolumeRamp$address() {
        return FMOD_ChannelGroup_GetVolumeRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetVolumeRamp(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *ramp)
     * }
     */
    public static int FMOD_ChannelGroup_GetVolumeRamp(MemorySegment channelgroup, MemorySegment ramp) {
        var mh$ = FMOD_ChannelGroup_GetVolumeRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetVolumeRamp", channelgroup, ramp);
            }
            return (int)mh$.invokeExact(channelgroup, ramp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetAudibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetAudibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetAudibility(FMOD_CHANNELGROUP *channelgroup, float *audibility)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetAudibility$descriptor() {
        return FMOD_ChannelGroup_GetAudibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetAudibility(FMOD_CHANNELGROUP *channelgroup, float *audibility)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetAudibility$handle() {
        return FMOD_ChannelGroup_GetAudibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetAudibility(FMOD_CHANNELGROUP *channelgroup, float *audibility)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetAudibility$address() {
        return FMOD_ChannelGroup_GetAudibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetAudibility(FMOD_CHANNELGROUP *channelgroup, float *audibility)
     * }
     */
    public static int FMOD_ChannelGroup_GetAudibility(MemorySegment channelgroup, MemorySegment audibility) {
        var mh$ = FMOD_ChannelGroup_GetAudibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetAudibility", channelgroup, audibility);
            }
            return (int)mh$.invokeExact(channelgroup, audibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPitch(FMOD_CHANNELGROUP *channelgroup, float pitch)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetPitch$descriptor() {
        return FMOD_ChannelGroup_SetPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPitch(FMOD_CHANNELGROUP *channelgroup, float pitch)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetPitch$handle() {
        return FMOD_ChannelGroup_SetPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPitch(FMOD_CHANNELGROUP *channelgroup, float pitch)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetPitch$address() {
        return FMOD_ChannelGroup_SetPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPitch(FMOD_CHANNELGROUP *channelgroup, float pitch)
     * }
     */
    public static int FMOD_ChannelGroup_SetPitch(MemorySegment channelgroup, float pitch) {
        var mh$ = FMOD_ChannelGroup_SetPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetPitch", channelgroup, pitch);
            }
            return (int)mh$.invokeExact(channelgroup, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetPitch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetPitch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPitch(FMOD_CHANNELGROUP *channelgroup, float *pitch)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetPitch$descriptor() {
        return FMOD_ChannelGroup_GetPitch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPitch(FMOD_CHANNELGROUP *channelgroup, float *pitch)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetPitch$handle() {
        return FMOD_ChannelGroup_GetPitch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPitch(FMOD_CHANNELGROUP *channelgroup, float *pitch)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetPitch$address() {
        return FMOD_ChannelGroup_GetPitch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetPitch(FMOD_CHANNELGROUP *channelgroup, float *pitch)
     * }
     */
    public static int FMOD_ChannelGroup_GetPitch(MemorySegment channelgroup, MemorySegment pitch) {
        var mh$ = FMOD_ChannelGroup_GetPitch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetPitch", channelgroup, pitch);
            }
            return (int)mh$.invokeExact(channelgroup, pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetMute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetMute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL mute)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetMute$descriptor() {
        return FMOD_ChannelGroup_SetMute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL mute)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetMute$handle() {
        return FMOD_ChannelGroup_SetMute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL mute)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetMute$address() {
        return FMOD_ChannelGroup_SetMute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL mute)
     * }
     */
    public static int FMOD_ChannelGroup_SetMute(MemorySegment channelgroup, int mute) {
        var mh$ = FMOD_ChannelGroup_SetMute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetMute", channelgroup, mute);
            }
            return (int)mh$.invokeExact(channelgroup, mute);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetMute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetMute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *mute)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetMute$descriptor() {
        return FMOD_ChannelGroup_GetMute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *mute)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetMute$handle() {
        return FMOD_ChannelGroup_GetMute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *mute)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetMute$address() {
        return FMOD_ChannelGroup_GetMute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMute(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *mute)
     * }
     */
    public static int FMOD_ChannelGroup_GetMute(MemorySegment channelgroup, MemorySegment mute) {
        var mh$ = FMOD_ChannelGroup_GetMute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetMute", channelgroup, mute);
            }
            return (int)mh$.invokeExact(channelgroup, mute);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetReverbProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetReverbProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float wet)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetReverbProperties$descriptor() {
        return FMOD_ChannelGroup_SetReverbProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float wet)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetReverbProperties$handle() {
        return FMOD_ChannelGroup_SetReverbProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float wet)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetReverbProperties$address() {
        return FMOD_ChannelGroup_SetReverbProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float wet)
     * }
     */
    public static int FMOD_ChannelGroup_SetReverbProperties(MemorySegment channelgroup, int instance, float wet) {
        var mh$ = FMOD_ChannelGroup_SetReverbProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetReverbProperties", channelgroup, instance, wet);
            }
            return (int)mh$.invokeExact(channelgroup, instance, wet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetReverbProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetReverbProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float *wet)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetReverbProperties$descriptor() {
        return FMOD_ChannelGroup_GetReverbProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float *wet)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetReverbProperties$handle() {
        return FMOD_ChannelGroup_GetReverbProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float *wet)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetReverbProperties$address() {
        return FMOD_ChannelGroup_GetReverbProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetReverbProperties(FMOD_CHANNELGROUP *channelgroup, int instance, float *wet)
     * }
     */
    public static int FMOD_ChannelGroup_GetReverbProperties(MemorySegment channelgroup, int instance, MemorySegment wet) {
        var mh$ = FMOD_ChannelGroup_GetReverbProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetReverbProperties", channelgroup, instance, wet);
            }
            return (int)mh$.invokeExact(channelgroup, instance, wet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetLowPassGain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetLowPassGain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float gain)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetLowPassGain$descriptor() {
        return FMOD_ChannelGroup_SetLowPassGain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float gain)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetLowPassGain$handle() {
        return FMOD_ChannelGroup_SetLowPassGain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float gain)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetLowPassGain$address() {
        return FMOD_ChannelGroup_SetLowPassGain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float gain)
     * }
     */
    public static int FMOD_ChannelGroup_SetLowPassGain(MemorySegment channelgroup, float gain) {
        var mh$ = FMOD_ChannelGroup_SetLowPassGain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetLowPassGain", channelgroup, gain);
            }
            return (int)mh$.invokeExact(channelgroup, gain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetLowPassGain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetLowPassGain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float *gain)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetLowPassGain$descriptor() {
        return FMOD_ChannelGroup_GetLowPassGain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float *gain)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetLowPassGain$handle() {
        return FMOD_ChannelGroup_GetLowPassGain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float *gain)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetLowPassGain$address() {
        return FMOD_ChannelGroup_GetLowPassGain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetLowPassGain(FMOD_CHANNELGROUP *channelgroup, float *gain)
     * }
     */
    public static int FMOD_ChannelGroup_GetLowPassGain(MemorySegment channelgroup, MemorySegment gain) {
        var mh$ = FMOD_ChannelGroup_GetLowPassGain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetLowPassGain", channelgroup, gain);
            }
            return (int)mh$.invokeExact(channelgroup, gain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE mode)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetMode$descriptor() {
        return FMOD_ChannelGroup_SetMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE mode)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetMode$handle() {
        return FMOD_ChannelGroup_SetMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE mode)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetMode$address() {
        return FMOD_ChannelGroup_SetMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE mode)
     * }
     */
    public static int FMOD_ChannelGroup_SetMode(MemorySegment channelgroup, int mode) {
        var mh$ = FMOD_ChannelGroup_SetMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetMode", channelgroup, mode);
            }
            return (int)mh$.invokeExact(channelgroup, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE *mode)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetMode$descriptor() {
        return FMOD_ChannelGroup_GetMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE *mode)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetMode$handle() {
        return FMOD_ChannelGroup_GetMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE *mode)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetMode$address() {
        return FMOD_ChannelGroup_GetMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMode(FMOD_CHANNELGROUP *channelgroup, FMOD_MODE *mode)
     * }
     */
    public static int FMOD_ChannelGroup_GetMode(MemorySegment channelgroup, MemorySegment mode) {
        var mh$ = FMOD_ChannelGroup_GetMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetMode", channelgroup, mode);
            }
            return (int)mh$.invokeExact(channelgroup, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetCallback(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELCONTROL_CALLBACK callback)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetCallback$descriptor() {
        return FMOD_ChannelGroup_SetCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetCallback(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELCONTROL_CALLBACK callback)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetCallback$handle() {
        return FMOD_ChannelGroup_SetCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetCallback(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELCONTROL_CALLBACK callback)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetCallback$address() {
        return FMOD_ChannelGroup_SetCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetCallback(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELCONTROL_CALLBACK callback)
     * }
     */
    public static int FMOD_ChannelGroup_SetCallback(MemorySegment channelgroup, MemorySegment callback) {
        var mh$ = FMOD_ChannelGroup_SetCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetCallback", channelgroup, callback);
            }
            return (int)mh$.invokeExact(channelgroup, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_IsPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_IsPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_IsPlaying(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *isplaying)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_IsPlaying$descriptor() {
        return FMOD_ChannelGroup_IsPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_IsPlaying(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *isplaying)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_IsPlaying$handle() {
        return FMOD_ChannelGroup_IsPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_IsPlaying(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *isplaying)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_IsPlaying$address() {
        return FMOD_ChannelGroup_IsPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_IsPlaying(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *isplaying)
     * }
     */
    public static int FMOD_ChannelGroup_IsPlaying(MemorySegment channelgroup, MemorySegment isplaying) {
        var mh$ = FMOD_ChannelGroup_IsPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_IsPlaying", channelgroup, isplaying);
            }
            return (int)mh$.invokeExact(channelgroup, isplaying);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPan(FMOD_CHANNELGROUP *channelgroup, float pan)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetPan$descriptor() {
        return FMOD_ChannelGroup_SetPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPan(FMOD_CHANNELGROUP *channelgroup, float pan)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetPan$handle() {
        return FMOD_ChannelGroup_SetPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPan(FMOD_CHANNELGROUP *channelgroup, float pan)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetPan$address() {
        return FMOD_ChannelGroup_SetPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetPan(FMOD_CHANNELGROUP *channelgroup, float pan)
     * }
     */
    public static int FMOD_ChannelGroup_SetPan(MemorySegment channelgroup, float pan) {
        var mh$ = FMOD_ChannelGroup_SetPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetPan", channelgroup, pan);
            }
            return (int)mh$.invokeExact(channelgroup, pan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetMixLevelsOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetMixLevelsOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsOutput(FMOD_CHANNELGROUP *channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetMixLevelsOutput$descriptor() {
        return FMOD_ChannelGroup_SetMixLevelsOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsOutput(FMOD_CHANNELGROUP *channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetMixLevelsOutput$handle() {
        return FMOD_ChannelGroup_SetMixLevelsOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsOutput(FMOD_CHANNELGROUP *channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetMixLevelsOutput$address() {
        return FMOD_ChannelGroup_SetMixLevelsOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsOutput(FMOD_CHANNELGROUP *channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
     * }
     */
    public static int FMOD_ChannelGroup_SetMixLevelsOutput(MemorySegment channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright) {
        var mh$ = FMOD_ChannelGroup_SetMixLevelsOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetMixLevelsOutput", channelgroup, frontleft, frontright, center, lfe, surroundleft, surroundright, backleft, backright);
            }
            return (int)mh$.invokeExact(channelgroup, frontleft, frontright, center, lfe, surroundleft, surroundright, backleft, backright);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetMixLevelsInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetMixLevelsInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsInput(FMOD_CHANNELGROUP *channelgroup, float *levels, int numlevels)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetMixLevelsInput$descriptor() {
        return FMOD_ChannelGroup_SetMixLevelsInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsInput(FMOD_CHANNELGROUP *channelgroup, float *levels, int numlevels)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetMixLevelsInput$handle() {
        return FMOD_ChannelGroup_SetMixLevelsInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsInput(FMOD_CHANNELGROUP *channelgroup, float *levels, int numlevels)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetMixLevelsInput$address() {
        return FMOD_ChannelGroup_SetMixLevelsInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixLevelsInput(FMOD_CHANNELGROUP *channelgroup, float *levels, int numlevels)
     * }
     */
    public static int FMOD_ChannelGroup_SetMixLevelsInput(MemorySegment channelgroup, MemorySegment levels, int numlevels) {
        var mh$ = FMOD_ChannelGroup_SetMixLevelsInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetMixLevelsInput", channelgroup, levels, numlevels);
            }
            return (int)mh$.invokeExact(channelgroup, levels, numlevels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetMixMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetMixMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetMixMatrix$descriptor() {
        return FMOD_ChannelGroup_SetMixMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetMixMatrix$handle() {
        return FMOD_ChannelGroup_SetMixMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetMixMatrix$address() {
        return FMOD_ChannelGroup_SetMixMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static int FMOD_ChannelGroup_SetMixMatrix(MemorySegment channelgroup, MemorySegment matrix, int outchannels, int inchannels, int inchannel_hop) {
        var mh$ = FMOD_ChannelGroup_SetMixMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetMixMatrix", channelgroup, matrix, outchannels, inchannels, inchannel_hop);
            }
            return (int)mh$.invokeExact(channelgroup, matrix, outchannels, inchannels, inchannel_hop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetMixMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetMixMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetMixMatrix$descriptor() {
        return FMOD_ChannelGroup_GetMixMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetMixMatrix$handle() {
        return FMOD_ChannelGroup_GetMixMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetMixMatrix$address() {
        return FMOD_ChannelGroup_GetMixMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetMixMatrix(FMOD_CHANNELGROUP *channelgroup, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static int FMOD_ChannelGroup_GetMixMatrix(MemorySegment channelgroup, MemorySegment matrix, MemorySegment outchannels, MemorySegment inchannels, int inchannel_hop) {
        var mh$ = FMOD_ChannelGroup_GetMixMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetMixMatrix", channelgroup, matrix, outchannels, inchannels, inchannel_hop);
            }
            return (int)mh$.invokeExact(channelgroup, matrix, outchannels, inchannels, inchannel_hop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetDSPClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetDSPClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPClock(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock, unsigned long long *parentclock)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetDSPClock$descriptor() {
        return FMOD_ChannelGroup_GetDSPClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPClock(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock, unsigned long long *parentclock)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetDSPClock$handle() {
        return FMOD_ChannelGroup_GetDSPClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPClock(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock, unsigned long long *parentclock)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetDSPClock$address() {
        return FMOD_ChannelGroup_GetDSPClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPClock(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock, unsigned long long *parentclock)
     * }
     */
    public static int FMOD_ChannelGroup_GetDSPClock(MemorySegment channelgroup, MemorySegment dspclock, MemorySegment parentclock) {
        var mh$ = FMOD_ChannelGroup_GetDSPClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetDSPClock", channelgroup, dspclock, parentclock);
            }
            return (int)mh$.invokeExact(channelgroup, dspclock, parentclock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetDelay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_LONG_LONG,
            FmodCore.C_LONG_LONG,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetDelay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end, FMOD_BOOL stopchannels)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetDelay$descriptor() {
        return FMOD_ChannelGroup_SetDelay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end, FMOD_BOOL stopchannels)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetDelay$handle() {
        return FMOD_ChannelGroup_SetDelay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end, FMOD_BOOL stopchannels)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetDelay$address() {
        return FMOD_ChannelGroup_SetDelay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end, FMOD_BOOL stopchannels)
     * }
     */
    public static int FMOD_ChannelGroup_SetDelay(MemorySegment channelgroup, long dspclock_start, long dspclock_end, int stopchannels) {
        var mh$ = FMOD_ChannelGroup_SetDelay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetDelay", channelgroup, dspclock_start, dspclock_end, stopchannels);
            }
            return (int)mh$.invokeExact(channelgroup, dspclock_start, dspclock_end, stopchannels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetDelay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetDelay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock_start, unsigned long long *dspclock_end, FMOD_BOOL *stopchannels)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetDelay$descriptor() {
        return FMOD_ChannelGroup_GetDelay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock_start, unsigned long long *dspclock_end, FMOD_BOOL *stopchannels)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetDelay$handle() {
        return FMOD_ChannelGroup_GetDelay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock_start, unsigned long long *dspclock_end, FMOD_BOOL *stopchannels)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetDelay$address() {
        return FMOD_ChannelGroup_GetDelay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDelay(FMOD_CHANNELGROUP *channelgroup, unsigned long long *dspclock_start, unsigned long long *dspclock_end, FMOD_BOOL *stopchannels)
     * }
     */
    public static int FMOD_ChannelGroup_GetDelay(MemorySegment channelgroup, MemorySegment dspclock_start, MemorySegment dspclock_end, MemorySegment stopchannels) {
        var mh$ = FMOD_ChannelGroup_GetDelay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetDelay", channelgroup, dspclock_start, dspclock_end, stopchannels);
            }
            return (int)mh$.invokeExact(channelgroup, dspclock_start, dspclock_end, stopchannels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_AddFadePoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_LONG_LONG,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_AddFadePoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddFadePoint(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_AddFadePoint$descriptor() {
        return FMOD_ChannelGroup_AddFadePoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddFadePoint(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_AddFadePoint$handle() {
        return FMOD_ChannelGroup_AddFadePoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddFadePoint(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_AddFadePoint$address() {
        return FMOD_ChannelGroup_AddFadePoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddFadePoint(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static int FMOD_ChannelGroup_AddFadePoint(MemorySegment channelgroup, long dspclock, float volume) {
        var mh$ = FMOD_ChannelGroup_AddFadePoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_AddFadePoint", channelgroup, dspclock, volume);
            }
            return (int)mh$.invokeExact(channelgroup, dspclock, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetFadePointRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_LONG_LONG,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetFadePointRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetFadePointRamp(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetFadePointRamp$descriptor() {
        return FMOD_ChannelGroup_SetFadePointRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetFadePointRamp(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetFadePointRamp$handle() {
        return FMOD_ChannelGroup_SetFadePointRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetFadePointRamp(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetFadePointRamp$address() {
        return FMOD_ChannelGroup_SetFadePointRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetFadePointRamp(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock, float volume)
     * }
     */
    public static int FMOD_ChannelGroup_SetFadePointRamp(MemorySegment channelgroup, long dspclock, float volume) {
        var mh$ = FMOD_ChannelGroup_SetFadePointRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetFadePointRamp", channelgroup, dspclock, volume);
            }
            return (int)mh$.invokeExact(channelgroup, dspclock, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_RemoveFadePoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_LONG_LONG,
            FmodCore.C_LONG_LONG
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_RemoveFadePoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_RemoveFadePoints$descriptor() {
        return FMOD_ChannelGroup_RemoveFadePoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_RemoveFadePoints$handle() {
        return FMOD_ChannelGroup_RemoveFadePoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_RemoveFadePoints$address() {
        return FMOD_ChannelGroup_RemoveFadePoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned long long dspclock_start, unsigned long long dspclock_end)
     * }
     */
    public static int FMOD_ChannelGroup_RemoveFadePoints(MemorySegment channelgroup, long dspclock_start, long dspclock_end) {
        var mh$ = FMOD_ChannelGroup_RemoveFadePoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_RemoveFadePoints", channelgroup, dspclock_start, dspclock_end);
            }
            return (int)mh$.invokeExact(channelgroup, dspclock_start, dspclock_end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetFadePoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetFadePoints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned int *numpoints, unsigned long long *point_dspclock, float *point_volume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetFadePoints$descriptor() {
        return FMOD_ChannelGroup_GetFadePoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned int *numpoints, unsigned long long *point_dspclock, float *point_volume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetFadePoints$handle() {
        return FMOD_ChannelGroup_GetFadePoints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned int *numpoints, unsigned long long *point_dspclock, float *point_volume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetFadePoints$address() {
        return FMOD_ChannelGroup_GetFadePoints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetFadePoints(FMOD_CHANNELGROUP *channelgroup, unsigned int *numpoints, unsigned long long *point_dspclock, float *point_volume)
     * }
     */
    public static int FMOD_ChannelGroup_GetFadePoints(MemorySegment channelgroup, MemorySegment numpoints, MemorySegment point_dspclock, MemorySegment point_volume) {
        var mh$ = FMOD_ChannelGroup_GetFadePoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetFadePoints", channelgroup, numpoints, point_dspclock, point_volume);
            }
            return (int)mh$.invokeExact(channelgroup, numpoints, point_dspclock, point_volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetDSP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetDSP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP **dsp)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetDSP$descriptor() {
        return FMOD_ChannelGroup_GetDSP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP **dsp)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetDSP$handle() {
        return FMOD_ChannelGroup_GetDSP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP **dsp)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetDSP$address() {
        return FMOD_ChannelGroup_GetDSP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP **dsp)
     * }
     */
    public static int FMOD_ChannelGroup_GetDSP(MemorySegment channelgroup, int index, MemorySegment dsp) {
        var mh$ = FMOD_ChannelGroup_GetDSP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetDSP", channelgroup, index, dsp);
            }
            return (int)mh$.invokeExact(channelgroup, index, dsp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_AddDSP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_AddDSP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP *dsp)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_AddDSP$descriptor() {
        return FMOD_ChannelGroup_AddDSP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP *dsp)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_AddDSP$handle() {
        return FMOD_ChannelGroup_AddDSP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP *dsp)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_AddDSP$address() {
        return FMOD_ChannelGroup_AddDSP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddDSP(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_DSP *dsp)
     * }
     */
    public static int FMOD_ChannelGroup_AddDSP(MemorySegment channelgroup, int index, MemorySegment dsp) {
        var mh$ = FMOD_ChannelGroup_AddDSP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_AddDSP", channelgroup, index, dsp);
            }
            return (int)mh$.invokeExact(channelgroup, index, dsp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_RemoveDSP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_RemoveDSP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveDSP(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_RemoveDSP$descriptor() {
        return FMOD_ChannelGroup_RemoveDSP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveDSP(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_RemoveDSP$handle() {
        return FMOD_ChannelGroup_RemoveDSP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveDSP(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_RemoveDSP$address() {
        return FMOD_ChannelGroup_RemoveDSP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_RemoveDSP(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp)
     * }
     */
    public static int FMOD_ChannelGroup_RemoveDSP(MemorySegment channelgroup, MemorySegment dsp) {
        var mh$ = FMOD_ChannelGroup_RemoveDSP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_RemoveDSP", channelgroup, dsp);
            }
            return (int)mh$.invokeExact(channelgroup, dsp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetNumDSPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetNumDSPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumDSPs(FMOD_CHANNELGROUP *channelgroup, int *numdsps)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetNumDSPs$descriptor() {
        return FMOD_ChannelGroup_GetNumDSPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumDSPs(FMOD_CHANNELGROUP *channelgroup, int *numdsps)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetNumDSPs$handle() {
        return FMOD_ChannelGroup_GetNumDSPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumDSPs(FMOD_CHANNELGROUP *channelgroup, int *numdsps)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetNumDSPs$address() {
        return FMOD_ChannelGroup_GetNumDSPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumDSPs(FMOD_CHANNELGROUP *channelgroup, int *numdsps)
     * }
     */
    public static int FMOD_ChannelGroup_GetNumDSPs(MemorySegment channelgroup, MemorySegment numdsps) {
        var mh$ = FMOD_ChannelGroup_GetNumDSPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetNumDSPs", channelgroup, numdsps);
            }
            return (int)mh$.invokeExact(channelgroup, numdsps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetDSPIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetDSPIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int index)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetDSPIndex$descriptor() {
        return FMOD_ChannelGroup_SetDSPIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int index)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetDSPIndex$handle() {
        return FMOD_ChannelGroup_SetDSPIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int index)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetDSPIndex$address() {
        return FMOD_ChannelGroup_SetDSPIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int index)
     * }
     */
    public static int FMOD_ChannelGroup_SetDSPIndex(MemorySegment channelgroup, MemorySegment dsp, int index) {
        var mh$ = FMOD_ChannelGroup_SetDSPIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetDSPIndex", channelgroup, dsp, index);
            }
            return (int)mh$.invokeExact(channelgroup, dsp, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetDSPIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetDSPIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int *index)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetDSPIndex$descriptor() {
        return FMOD_ChannelGroup_GetDSPIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int *index)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetDSPIndex$handle() {
        return FMOD_ChannelGroup_GetDSPIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int *index)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetDSPIndex$address() {
        return FMOD_ChannelGroup_GetDSPIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetDSPIndex(FMOD_CHANNELGROUP *channelgroup, FMOD_DSP *dsp, int *index)
     * }
     */
    public static int FMOD_ChannelGroup_GetDSPIndex(MemorySegment channelgroup, MemorySegment dsp, MemorySegment index) {
        var mh$ = FMOD_ChannelGroup_GetDSPIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetDSPIndex", channelgroup, dsp, index);
            }
            return (int)mh$.invokeExact(channelgroup, dsp, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DAttributes(FMOD_CHANNELGROUP *channelgroup, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DAttributes$descriptor() {
        return FMOD_ChannelGroup_Set3DAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DAttributes(FMOD_CHANNELGROUP *channelgroup, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DAttributes$handle() {
        return FMOD_ChannelGroup_Set3DAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DAttributes(FMOD_CHANNELGROUP *channelgroup, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DAttributes$address() {
        return FMOD_ChannelGroup_Set3DAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DAttributes(FMOD_CHANNELGROUP *channelgroup, const FMOD_VECTOR *pos, const FMOD_VECTOR *vel)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DAttributes(MemorySegment channelgroup, MemorySegment pos, MemorySegment vel) {
        var mh$ = FMOD_ChannelGroup_Set3DAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DAttributes", channelgroup, pos, vel);
            }
            return (int)mh$.invokeExact(channelgroup, pos, vel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DAttributes(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DAttributes$descriptor() {
        return FMOD_ChannelGroup_Get3DAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DAttributes(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DAttributes$handle() {
        return FMOD_ChannelGroup_Get3DAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DAttributes(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DAttributes$address() {
        return FMOD_ChannelGroup_Get3DAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DAttributes(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *pos, FMOD_VECTOR *vel)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DAttributes(MemorySegment channelgroup, MemorySegment pos, MemorySegment vel) {
        var mh$ = FMOD_ChannelGroup_Get3DAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DAttributes", channelgroup, pos, vel);
            }
            return (int)mh$.invokeExact(channelgroup, pos, vel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DMinMaxDistance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DMinMaxDistance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float mindistance, float maxdistance)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DMinMaxDistance$descriptor() {
        return FMOD_ChannelGroup_Set3DMinMaxDistance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float mindistance, float maxdistance)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DMinMaxDistance$handle() {
        return FMOD_ChannelGroup_Set3DMinMaxDistance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float mindistance, float maxdistance)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DMinMaxDistance$address() {
        return FMOD_ChannelGroup_Set3DMinMaxDistance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float mindistance, float maxdistance)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DMinMaxDistance(MemorySegment channelgroup, float mindistance, float maxdistance) {
        var mh$ = FMOD_ChannelGroup_Set3DMinMaxDistance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DMinMaxDistance", channelgroup, mindistance, maxdistance);
            }
            return (int)mh$.invokeExact(channelgroup, mindistance, maxdistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DMinMaxDistance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DMinMaxDistance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float *mindistance, float *maxdistance)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DMinMaxDistance$descriptor() {
        return FMOD_ChannelGroup_Get3DMinMaxDistance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float *mindistance, float *maxdistance)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DMinMaxDistance$handle() {
        return FMOD_ChannelGroup_Get3DMinMaxDistance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float *mindistance, float *maxdistance)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DMinMaxDistance$address() {
        return FMOD_ChannelGroup_Get3DMinMaxDistance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DMinMaxDistance(FMOD_CHANNELGROUP *channelgroup, float *mindistance, float *maxdistance)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DMinMaxDistance(MemorySegment channelgroup, MemorySegment mindistance, MemorySegment maxdistance) {
        var mh$ = FMOD_ChannelGroup_Get3DMinMaxDistance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DMinMaxDistance", channelgroup, mindistance, maxdistance);
            }
            return (int)mh$.invokeExact(channelgroup, mindistance, maxdistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DConeSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DConeSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DConeSettings$descriptor() {
        return FMOD_ChannelGroup_Set3DConeSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DConeSettings$handle() {
        return FMOD_ChannelGroup_Set3DConeSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DConeSettings$address() {
        return FMOD_ChannelGroup_Set3DConeSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DConeSettings(MemorySegment channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume) {
        var mh$ = FMOD_ChannelGroup_Set3DConeSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DConeSettings", channelgroup, insideconeangle, outsideconeangle, outsidevolume);
            }
            return (int)mh$.invokeExact(channelgroup, insideconeangle, outsideconeangle, outsidevolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DConeSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DConeSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DConeSettings$descriptor() {
        return FMOD_ChannelGroup_Get3DConeSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DConeSettings$handle() {
        return FMOD_ChannelGroup_Get3DConeSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DConeSettings$address() {
        return FMOD_ChannelGroup_Get3DConeSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeSettings(FMOD_CHANNELGROUP *channelgroup, float *insideconeangle, float *outsideconeangle, float *outsidevolume)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DConeSettings(MemorySegment channelgroup, MemorySegment insideconeangle, MemorySegment outsideconeangle, MemorySegment outsidevolume) {
        var mh$ = FMOD_ChannelGroup_Get3DConeSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DConeSettings", channelgroup, insideconeangle, outsideconeangle, outsidevolume);
            }
            return (int)mh$.invokeExact(channelgroup, insideconeangle, outsideconeangle, outsidevolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DConeOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DConeOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DConeOrientation$descriptor() {
        return FMOD_ChannelGroup_Set3DConeOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DConeOrientation$handle() {
        return FMOD_ChannelGroup_Set3DConeOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DConeOrientation$address() {
        return FMOD_ChannelGroup_Set3DConeOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DConeOrientation(MemorySegment channelgroup, MemorySegment orientation) {
        var mh$ = FMOD_ChannelGroup_Set3DConeOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DConeOrientation", channelgroup, orientation);
            }
            return (int)mh$.invokeExact(channelgroup, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DConeOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DConeOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DConeOrientation$descriptor() {
        return FMOD_ChannelGroup_Get3DConeOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DConeOrientation$handle() {
        return FMOD_ChannelGroup_Get3DConeOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DConeOrientation$address() {
        return FMOD_ChannelGroup_Get3DConeOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DConeOrientation(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *orientation)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DConeOrientation(MemorySegment channelgroup, MemorySegment orientation) {
        var mh$ = FMOD_ChannelGroup_Get3DConeOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DConeOrientation", channelgroup, orientation);
            }
            return (int)mh$.invokeExact(channelgroup, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DCustomRolloff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DCustomRolloff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DCustomRolloff$descriptor() {
        return FMOD_ChannelGroup_Set3DCustomRolloff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DCustomRolloff$handle() {
        return FMOD_ChannelGroup_Set3DCustomRolloff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DCustomRolloff$address() {
        return FMOD_ChannelGroup_Set3DCustomRolloff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR *points, int numpoints)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DCustomRolloff(MemorySegment channelgroup, MemorySegment points, int numpoints) {
        var mh$ = FMOD_ChannelGroup_Set3DCustomRolloff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DCustomRolloff", channelgroup, points, numpoints);
            }
            return (int)mh$.invokeExact(channelgroup, points, numpoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DCustomRolloff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DCustomRolloff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DCustomRolloff$descriptor() {
        return FMOD_ChannelGroup_Get3DCustomRolloff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DCustomRolloff$handle() {
        return FMOD_ChannelGroup_Get3DCustomRolloff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DCustomRolloff$address() {
        return FMOD_ChannelGroup_Get3DCustomRolloff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DCustomRolloff(FMOD_CHANNELGROUP *channelgroup, FMOD_VECTOR **points, int *numpoints)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DCustomRolloff(MemorySegment channelgroup, MemorySegment points, MemorySegment numpoints) {
        var mh$ = FMOD_ChannelGroup_Get3DCustomRolloff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DCustomRolloff", channelgroup, points, numpoints);
            }
            return (int)mh$.invokeExact(channelgroup, points, numpoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DOcclusion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DOcclusion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float directocclusion, float reverbocclusion)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DOcclusion$descriptor() {
        return FMOD_ChannelGroup_Set3DOcclusion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float directocclusion, float reverbocclusion)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DOcclusion$handle() {
        return FMOD_ChannelGroup_Set3DOcclusion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float directocclusion, float reverbocclusion)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DOcclusion$address() {
        return FMOD_ChannelGroup_Set3DOcclusion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float directocclusion, float reverbocclusion)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DOcclusion(MemorySegment channelgroup, float directocclusion, float reverbocclusion) {
        var mh$ = FMOD_ChannelGroup_Set3DOcclusion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DOcclusion", channelgroup, directocclusion, reverbocclusion);
            }
            return (int)mh$.invokeExact(channelgroup, directocclusion, reverbocclusion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DOcclusion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DOcclusion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DOcclusion$descriptor() {
        return FMOD_ChannelGroup_Get3DOcclusion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DOcclusion$handle() {
        return FMOD_ChannelGroup_Get3DOcclusion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DOcclusion$address() {
        return FMOD_ChannelGroup_Get3DOcclusion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DOcclusion(FMOD_CHANNELGROUP *channelgroup, float *directocclusion, float *reverbocclusion)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DOcclusion(MemorySegment channelgroup, MemorySegment directocclusion, MemorySegment reverbocclusion) {
        var mh$ = FMOD_ChannelGroup_Get3DOcclusion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DOcclusion", channelgroup, directocclusion, reverbocclusion);
            }
            return (int)mh$.invokeExact(channelgroup, directocclusion, reverbocclusion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DSpread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DSpread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DSpread(FMOD_CHANNELGROUP *channelgroup, float angle)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DSpread$descriptor() {
        return FMOD_ChannelGroup_Set3DSpread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DSpread(FMOD_CHANNELGROUP *channelgroup, float angle)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DSpread$handle() {
        return FMOD_ChannelGroup_Set3DSpread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DSpread(FMOD_CHANNELGROUP *channelgroup, float angle)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DSpread$address() {
        return FMOD_ChannelGroup_Set3DSpread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DSpread(FMOD_CHANNELGROUP *channelgroup, float angle)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DSpread(MemorySegment channelgroup, float angle) {
        var mh$ = FMOD_ChannelGroup_Set3DSpread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DSpread", channelgroup, angle);
            }
            return (int)mh$.invokeExact(channelgroup, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DSpread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DSpread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DSpread(FMOD_CHANNELGROUP *channelgroup, float *angle)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DSpread$descriptor() {
        return FMOD_ChannelGroup_Get3DSpread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DSpread(FMOD_CHANNELGROUP *channelgroup, float *angle)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DSpread$handle() {
        return FMOD_ChannelGroup_Get3DSpread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DSpread(FMOD_CHANNELGROUP *channelgroup, float *angle)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DSpread$address() {
        return FMOD_ChannelGroup_Get3DSpread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DSpread(FMOD_CHANNELGROUP *channelgroup, float *angle)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DSpread(MemorySegment channelgroup, MemorySegment angle) {
        var mh$ = FMOD_ChannelGroup_Get3DSpread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DSpread", channelgroup, angle);
            }
            return (int)mh$.invokeExact(channelgroup, angle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DLevel$descriptor() {
        return FMOD_ChannelGroup_Set3DLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DLevel$handle() {
        return FMOD_ChannelGroup_Set3DLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DLevel$address() {
        return FMOD_ChannelGroup_Set3DLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DLevel(MemorySegment channelgroup, float level) {
        var mh$ = FMOD_ChannelGroup_Set3DLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DLevel", channelgroup, level);
            }
            return (int)mh$.invokeExact(channelgroup, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DLevel$descriptor() {
        return FMOD_ChannelGroup_Get3DLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DLevel$handle() {
        return FMOD_ChannelGroup_Get3DLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DLevel$address() {
        return FMOD_ChannelGroup_Get3DLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DLevel(MemorySegment channelgroup, MemorySegment level) {
        var mh$ = FMOD_ChannelGroup_Get3DLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DLevel", channelgroup, level);
            }
            return (int)mh$.invokeExact(channelgroup, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DDopplerLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DDopplerLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DDopplerLevel$descriptor() {
        return FMOD_ChannelGroup_Set3DDopplerLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DDopplerLevel$handle() {
        return FMOD_ChannelGroup_Set3DDopplerLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DDopplerLevel$address() {
        return FMOD_ChannelGroup_Set3DDopplerLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float level)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DDopplerLevel(MemorySegment channelgroup, float level) {
        var mh$ = FMOD_ChannelGroup_Set3DDopplerLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DDopplerLevel", channelgroup, level);
            }
            return (int)mh$.invokeExact(channelgroup, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DDopplerLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DDopplerLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DDopplerLevel$descriptor() {
        return FMOD_ChannelGroup_Get3DDopplerLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DDopplerLevel$handle() {
        return FMOD_ChannelGroup_Get3DDopplerLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DDopplerLevel$address() {
        return FMOD_ChannelGroup_Get3DDopplerLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDopplerLevel(FMOD_CHANNELGROUP *channelgroup, float *level)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DDopplerLevel(MemorySegment channelgroup, MemorySegment level) {
        var mh$ = FMOD_ChannelGroup_Get3DDopplerLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DDopplerLevel", channelgroup, level);
            }
            return (int)mh$.invokeExact(channelgroup, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Set3DDistanceFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Set3DDistanceFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Set3DDistanceFilter$descriptor() {
        return FMOD_ChannelGroup_Set3DDistanceFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Set3DDistanceFilter$handle() {
        return FMOD_ChannelGroup_Set3DDistanceFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Set3DDistanceFilter$address() {
        return FMOD_ChannelGroup_Set3DDistanceFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Set3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL custom, float customLevel, float centerFreq)
     * }
     */
    public static int FMOD_ChannelGroup_Set3DDistanceFilter(MemorySegment channelgroup, int custom, float customLevel, float centerFreq) {
        var mh$ = FMOD_ChannelGroup_Set3DDistanceFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Set3DDistanceFilter", channelgroup, custom, customLevel, centerFreq);
            }
            return (int)mh$.invokeExact(channelgroup, custom, customLevel, centerFreq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Get3DDistanceFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Get3DDistanceFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Get3DDistanceFilter$descriptor() {
        return FMOD_ChannelGroup_Get3DDistanceFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Get3DDistanceFilter$handle() {
        return FMOD_ChannelGroup_Get3DDistanceFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Get3DDistanceFilter$address() {
        return FMOD_ChannelGroup_Get3DDistanceFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Get3DDistanceFilter(FMOD_CHANNELGROUP *channelgroup, FMOD_BOOL *custom, float *customLevel, float *centerFreq)
     * }
     */
    public static int FMOD_ChannelGroup_Get3DDistanceFilter(MemorySegment channelgroup, MemorySegment custom, MemorySegment customLevel, MemorySegment centerFreq) {
        var mh$ = FMOD_ChannelGroup_Get3DDistanceFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Get3DDistanceFilter", channelgroup, custom, customLevel, centerFreq);
            }
            return (int)mh$.invokeExact(channelgroup, custom, customLevel, centerFreq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetUserData(FMOD_CHANNELGROUP *channelgroup, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_SetUserData$descriptor() {
        return FMOD_ChannelGroup_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetUserData(FMOD_CHANNELGROUP *channelgroup, void *userdata)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_SetUserData$handle() {
        return FMOD_ChannelGroup_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetUserData(FMOD_CHANNELGROUP *channelgroup, void *userdata)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_SetUserData$address() {
        return FMOD_ChannelGroup_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_SetUserData(FMOD_CHANNELGROUP *channelgroup, void *userdata)
     * }
     */
    public static int FMOD_ChannelGroup_SetUserData(MemorySegment channelgroup, MemorySegment userdata) {
        var mh$ = FMOD_ChannelGroup_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_SetUserData", channelgroup, userdata);
            }
            return (int)mh$.invokeExact(channelgroup, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetUserData(FMOD_CHANNELGROUP *channelgroup, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetUserData$descriptor() {
        return FMOD_ChannelGroup_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetUserData(FMOD_CHANNELGROUP *channelgroup, void **userdata)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetUserData$handle() {
        return FMOD_ChannelGroup_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetUserData(FMOD_CHANNELGROUP *channelgroup, void **userdata)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetUserData$address() {
        return FMOD_ChannelGroup_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetUserData(FMOD_CHANNELGROUP *channelgroup, void **userdata)
     * }
     */
    public static int FMOD_ChannelGroup_GetUserData(MemorySegment channelgroup, MemorySegment userdata) {
        var mh$ = FMOD_ChannelGroup_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetUserData", channelgroup, userdata);
            }
            return (int)mh$.invokeExact(channelgroup, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Release(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_Release$descriptor() {
        return FMOD_ChannelGroup_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Release(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_Release$handle() {
        return FMOD_ChannelGroup_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Release(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_Release$address() {
        return FMOD_ChannelGroup_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_Release(FMOD_CHANNELGROUP *channelgroup)
     * }
     */
    public static int FMOD_ChannelGroup_Release(MemorySegment channelgroup) {
        var mh$ = FMOD_ChannelGroup_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_Release", channelgroup);
            }
            return (int)mh$.invokeExact(channelgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_AddGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_AddGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP *group, FMOD_BOOL propagatedspclock, FMOD_DSPCONNECTION **connection)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_AddGroup$descriptor() {
        return FMOD_ChannelGroup_AddGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP *group, FMOD_BOOL propagatedspclock, FMOD_DSPCONNECTION **connection)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_AddGroup$handle() {
        return FMOD_ChannelGroup_AddGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP *group, FMOD_BOOL propagatedspclock, FMOD_DSPCONNECTION **connection)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_AddGroup$address() {
        return FMOD_ChannelGroup_AddGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_AddGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP *group, FMOD_BOOL propagatedspclock, FMOD_DSPCONNECTION **connection)
     * }
     */
    public static int FMOD_ChannelGroup_AddGroup(MemorySegment channelgroup, MemorySegment group, int propagatedspclock, MemorySegment connection) {
        var mh$ = FMOD_ChannelGroup_AddGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_AddGroup", channelgroup, group, propagatedspclock, connection);
            }
            return (int)mh$.invokeExact(channelgroup, group, propagatedspclock, connection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetNumGroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetNumGroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumGroups(FMOD_CHANNELGROUP *channelgroup, int *numgroups)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetNumGroups$descriptor() {
        return FMOD_ChannelGroup_GetNumGroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumGroups(FMOD_CHANNELGROUP *channelgroup, int *numgroups)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetNumGroups$handle() {
        return FMOD_ChannelGroup_GetNumGroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumGroups(FMOD_CHANNELGROUP *channelgroup, int *numgroups)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetNumGroups$address() {
        return FMOD_ChannelGroup_GetNumGroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumGroups(FMOD_CHANNELGROUP *channelgroup, int *numgroups)
     * }
     */
    public static int FMOD_ChannelGroup_GetNumGroups(MemorySegment channelgroup, MemorySegment numgroups) {
        var mh$ = FMOD_ChannelGroup_GetNumGroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetNumGroups", channelgroup, numgroups);
            }
            return (int)mh$.invokeExact(channelgroup, numgroups);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetGroup(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNELGROUP **group)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetGroup$descriptor() {
        return FMOD_ChannelGroup_GetGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetGroup(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNELGROUP **group)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetGroup$handle() {
        return FMOD_ChannelGroup_GetGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetGroup(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNELGROUP **group)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetGroup$address() {
        return FMOD_ChannelGroup_GetGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetGroup(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNELGROUP **group)
     * }
     */
    public static int FMOD_ChannelGroup_GetGroup(MemorySegment channelgroup, int index, MemorySegment group) {
        var mh$ = FMOD_ChannelGroup_GetGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetGroup", channelgroup, index, group);
            }
            return (int)mh$.invokeExact(channelgroup, index, group);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetParentGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetParentGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetParentGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP **group)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetParentGroup$descriptor() {
        return FMOD_ChannelGroup_GetParentGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetParentGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP **group)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetParentGroup$handle() {
        return FMOD_ChannelGroup_GetParentGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetParentGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP **group)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetParentGroup$address() {
        return FMOD_ChannelGroup_GetParentGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetParentGroup(FMOD_CHANNELGROUP *channelgroup, FMOD_CHANNELGROUP **group)
     * }
     */
    public static int FMOD_ChannelGroup_GetParentGroup(MemorySegment channelgroup, MemorySegment group) {
        var mh$ = FMOD_ChannelGroup_GetParentGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetParentGroup", channelgroup, group);
            }
            return (int)mh$.invokeExact(channelgroup, group);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetName(FMOD_CHANNELGROUP *channelgroup, char *name, int namelen)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetName$descriptor() {
        return FMOD_ChannelGroup_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetName(FMOD_CHANNELGROUP *channelgroup, char *name, int namelen)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetName$handle() {
        return FMOD_ChannelGroup_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetName(FMOD_CHANNELGROUP *channelgroup, char *name, int namelen)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetName$address() {
        return FMOD_ChannelGroup_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetName(FMOD_CHANNELGROUP *channelgroup, char *name, int namelen)
     * }
     */
    public static int FMOD_ChannelGroup_GetName(MemorySegment channelgroup, MemorySegment name, int namelen) {
        var mh$ = FMOD_ChannelGroup_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetName", channelgroup, name, namelen);
            }
            return (int)mh$.invokeExact(channelgroup, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetNumChannels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetNumChannels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumChannels(FMOD_CHANNELGROUP *channelgroup, int *numchannels)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetNumChannels$descriptor() {
        return FMOD_ChannelGroup_GetNumChannels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumChannels(FMOD_CHANNELGROUP *channelgroup, int *numchannels)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetNumChannels$handle() {
        return FMOD_ChannelGroup_GetNumChannels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumChannels(FMOD_CHANNELGROUP *channelgroup, int *numchannels)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetNumChannels$address() {
        return FMOD_ChannelGroup_GetNumChannels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetNumChannels(FMOD_CHANNELGROUP *channelgroup, int *numchannels)
     * }
     */
    public static int FMOD_ChannelGroup_GetNumChannels(MemorySegment channelgroup, MemorySegment numchannels) {
        var mh$ = FMOD_ChannelGroup_GetNumChannels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetNumChannels", channelgroup, numchannels);
            }
            return (int)mh$.invokeExact(channelgroup, numchannels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_ChannelGroup_GetChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_ChannelGroup_GetChannel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetChannel(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNEL **channel)
     * }
     */
    public static FunctionDescriptor FMOD_ChannelGroup_GetChannel$descriptor() {
        return FMOD_ChannelGroup_GetChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetChannel(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNEL **channel)
     * }
     */
    public static MethodHandle FMOD_ChannelGroup_GetChannel$handle() {
        return FMOD_ChannelGroup_GetChannel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetChannel(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNEL **channel)
     * }
     */
    public static MemorySegment FMOD_ChannelGroup_GetChannel$address() {
        return FMOD_ChannelGroup_GetChannel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_ChannelGroup_GetChannel(FMOD_CHANNELGROUP *channelgroup, int index, FMOD_CHANNEL **channel)
     * }
     */
    public static int FMOD_ChannelGroup_GetChannel(MemorySegment channelgroup, int index, MemorySegment channel) {
        var mh$ = FMOD_ChannelGroup_GetChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_ChannelGroup_GetChannel", channelgroup, index, channel);
            }
            return (int)mh$.invokeExact(channelgroup, index, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Release(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_Release$descriptor() {
        return FMOD_SoundGroup_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Release(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_Release$handle() {
        return FMOD_SoundGroup_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Release(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_Release$address() {
        return FMOD_SoundGroup_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Release(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static int FMOD_SoundGroup_Release(MemorySegment soundgroup) {
        var mh$ = FMOD_SoundGroup_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_Release", soundgroup);
            }
            return (int)mh$.invokeExact(soundgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetSystemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetSystemObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSystemObject(FMOD_SOUNDGROUP *soundgroup, FMOD_SYSTEM **system)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetSystemObject$descriptor() {
        return FMOD_SoundGroup_GetSystemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSystemObject(FMOD_SOUNDGROUP *soundgroup, FMOD_SYSTEM **system)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetSystemObject$handle() {
        return FMOD_SoundGroup_GetSystemObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSystemObject(FMOD_SOUNDGROUP *soundgroup, FMOD_SYSTEM **system)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetSystemObject$address() {
        return FMOD_SoundGroup_GetSystemObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSystemObject(FMOD_SOUNDGROUP *soundgroup, FMOD_SYSTEM **system)
     * }
     */
    public static int FMOD_SoundGroup_GetSystemObject(MemorySegment soundgroup, MemorySegment system) {
        var mh$ = FMOD_SoundGroup_GetSystemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetSystemObject", soundgroup, system);
            }
            return (int)mh$.invokeExact(soundgroup, system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_SetMaxAudible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_SetMaxAudible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int maxaudible)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_SetMaxAudible$descriptor() {
        return FMOD_SoundGroup_SetMaxAudible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int maxaudible)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_SetMaxAudible$handle() {
        return FMOD_SoundGroup_SetMaxAudible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int maxaudible)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_SetMaxAudible$address() {
        return FMOD_SoundGroup_SetMaxAudible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int maxaudible)
     * }
     */
    public static int FMOD_SoundGroup_SetMaxAudible(MemorySegment soundgroup, int maxaudible) {
        var mh$ = FMOD_SoundGroup_SetMaxAudible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_SetMaxAudible", soundgroup, maxaudible);
            }
            return (int)mh$.invokeExact(soundgroup, maxaudible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetMaxAudible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetMaxAudible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int *maxaudible)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetMaxAudible$descriptor() {
        return FMOD_SoundGroup_GetMaxAudible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int *maxaudible)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetMaxAudible$handle() {
        return FMOD_SoundGroup_GetMaxAudible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int *maxaudible)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetMaxAudible$address() {
        return FMOD_SoundGroup_GetMaxAudible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudible(FMOD_SOUNDGROUP *soundgroup, int *maxaudible)
     * }
     */
    public static int FMOD_SoundGroup_GetMaxAudible(MemorySegment soundgroup, MemorySegment maxaudible) {
        var mh$ = FMOD_SoundGroup_GetMaxAudible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetMaxAudible", soundgroup, maxaudible);
            }
            return (int)mh$.invokeExact(soundgroup, maxaudible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_SetMaxAudibleBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_SetMaxAudibleBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR behavior)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_SetMaxAudibleBehavior$descriptor() {
        return FMOD_SoundGroup_SetMaxAudibleBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR behavior)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_SetMaxAudibleBehavior$handle() {
        return FMOD_SoundGroup_SetMaxAudibleBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR behavior)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_SetMaxAudibleBehavior$address() {
        return FMOD_SoundGroup_SetMaxAudibleBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR behavior)
     * }
     */
    public static int FMOD_SoundGroup_SetMaxAudibleBehavior(MemorySegment soundgroup, int behavior) {
        var mh$ = FMOD_SoundGroup_SetMaxAudibleBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_SetMaxAudibleBehavior", soundgroup, behavior);
            }
            return (int)mh$.invokeExact(soundgroup, behavior);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetMaxAudibleBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetMaxAudibleBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR *behavior)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetMaxAudibleBehavior$descriptor() {
        return FMOD_SoundGroup_GetMaxAudibleBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR *behavior)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetMaxAudibleBehavior$handle() {
        return FMOD_SoundGroup_GetMaxAudibleBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR *behavior)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetMaxAudibleBehavior$address() {
        return FMOD_SoundGroup_GetMaxAudibleBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMaxAudibleBehavior(FMOD_SOUNDGROUP *soundgroup, FMOD_SOUNDGROUP_BEHAVIOR *behavior)
     * }
     */
    public static int FMOD_SoundGroup_GetMaxAudibleBehavior(MemorySegment soundgroup, MemorySegment behavior) {
        var mh$ = FMOD_SoundGroup_GetMaxAudibleBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetMaxAudibleBehavior", soundgroup, behavior);
            }
            return (int)mh$.invokeExact(soundgroup, behavior);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_SetMuteFadeSpeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_SetMuteFadeSpeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float speed)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_SetMuteFadeSpeed$descriptor() {
        return FMOD_SoundGroup_SetMuteFadeSpeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float speed)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_SetMuteFadeSpeed$handle() {
        return FMOD_SoundGroup_SetMuteFadeSpeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float speed)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_SetMuteFadeSpeed$address() {
        return FMOD_SoundGroup_SetMuteFadeSpeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float speed)
     * }
     */
    public static int FMOD_SoundGroup_SetMuteFadeSpeed(MemorySegment soundgroup, float speed) {
        var mh$ = FMOD_SoundGroup_SetMuteFadeSpeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_SetMuteFadeSpeed", soundgroup, speed);
            }
            return (int)mh$.invokeExact(soundgroup, speed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetMuteFadeSpeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetMuteFadeSpeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float *speed)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetMuteFadeSpeed$descriptor() {
        return FMOD_SoundGroup_GetMuteFadeSpeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float *speed)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetMuteFadeSpeed$handle() {
        return FMOD_SoundGroup_GetMuteFadeSpeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float *speed)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetMuteFadeSpeed$address() {
        return FMOD_SoundGroup_GetMuteFadeSpeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetMuteFadeSpeed(FMOD_SOUNDGROUP *soundgroup, float *speed)
     * }
     */
    public static int FMOD_SoundGroup_GetMuteFadeSpeed(MemorySegment soundgroup, MemorySegment speed) {
        var mh$ = FMOD_SoundGroup_GetMuteFadeSpeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetMuteFadeSpeed", soundgroup, speed);
            }
            return (int)mh$.invokeExact(soundgroup, speed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_SetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_SetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetVolume(FMOD_SOUNDGROUP *soundgroup, float volume)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_SetVolume$descriptor() {
        return FMOD_SoundGroup_SetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetVolume(FMOD_SOUNDGROUP *soundgroup, float volume)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_SetVolume$handle() {
        return FMOD_SoundGroup_SetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetVolume(FMOD_SOUNDGROUP *soundgroup, float volume)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_SetVolume$address() {
        return FMOD_SoundGroup_SetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetVolume(FMOD_SOUNDGROUP *soundgroup, float volume)
     * }
     */
    public static int FMOD_SoundGroup_SetVolume(MemorySegment soundgroup, float volume) {
        var mh$ = FMOD_SoundGroup_SetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_SetVolume", soundgroup, volume);
            }
            return (int)mh$.invokeExact(soundgroup, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetVolume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetVolume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetVolume(FMOD_SOUNDGROUP *soundgroup, float *volume)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetVolume$descriptor() {
        return FMOD_SoundGroup_GetVolume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetVolume(FMOD_SOUNDGROUP *soundgroup, float *volume)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetVolume$handle() {
        return FMOD_SoundGroup_GetVolume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetVolume(FMOD_SOUNDGROUP *soundgroup, float *volume)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetVolume$address() {
        return FMOD_SoundGroup_GetVolume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetVolume(FMOD_SOUNDGROUP *soundgroup, float *volume)
     * }
     */
    public static int FMOD_SoundGroup_GetVolume(MemorySegment soundgroup, MemorySegment volume) {
        var mh$ = FMOD_SoundGroup_GetVolume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetVolume", soundgroup, volume);
            }
            return (int)mh$.invokeExact(soundgroup, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_Stop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_Stop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Stop(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_Stop$descriptor() {
        return FMOD_SoundGroup_Stop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Stop(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_Stop$handle() {
        return FMOD_SoundGroup_Stop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Stop(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_Stop$address() {
        return FMOD_SoundGroup_Stop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_Stop(FMOD_SOUNDGROUP *soundgroup)
     * }
     */
    public static int FMOD_SoundGroup_Stop(MemorySegment soundgroup) {
        var mh$ = FMOD_SoundGroup_Stop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_Stop", soundgroup);
            }
            return (int)mh$.invokeExact(soundgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetName(FMOD_SOUNDGROUP *soundgroup, char *name, int namelen)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetName$descriptor() {
        return FMOD_SoundGroup_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetName(FMOD_SOUNDGROUP *soundgroup, char *name, int namelen)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetName$handle() {
        return FMOD_SoundGroup_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetName(FMOD_SOUNDGROUP *soundgroup, char *name, int namelen)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetName$address() {
        return FMOD_SoundGroup_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetName(FMOD_SOUNDGROUP *soundgroup, char *name, int namelen)
     * }
     */
    public static int FMOD_SoundGroup_GetName(MemorySegment soundgroup, MemorySegment name, int namelen) {
        var mh$ = FMOD_SoundGroup_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetName", soundgroup, name, namelen);
            }
            return (int)mh$.invokeExact(soundgroup, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetNumSounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetNumSounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumSounds(FMOD_SOUNDGROUP *soundgroup, int *numsounds)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetNumSounds$descriptor() {
        return FMOD_SoundGroup_GetNumSounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumSounds(FMOD_SOUNDGROUP *soundgroup, int *numsounds)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetNumSounds$handle() {
        return FMOD_SoundGroup_GetNumSounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumSounds(FMOD_SOUNDGROUP *soundgroup, int *numsounds)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetNumSounds$address() {
        return FMOD_SoundGroup_GetNumSounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumSounds(FMOD_SOUNDGROUP *soundgroup, int *numsounds)
     * }
     */
    public static int FMOD_SoundGroup_GetNumSounds(MemorySegment soundgroup, MemorySegment numsounds) {
        var mh$ = FMOD_SoundGroup_GetNumSounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetNumSounds", soundgroup, numsounds);
            }
            return (int)mh$.invokeExact(soundgroup, numsounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetSound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetSound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSound(FMOD_SOUNDGROUP *soundgroup, int index, FMOD_SOUND **sound)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetSound$descriptor() {
        return FMOD_SoundGroup_GetSound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSound(FMOD_SOUNDGROUP *soundgroup, int index, FMOD_SOUND **sound)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetSound$handle() {
        return FMOD_SoundGroup_GetSound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSound(FMOD_SOUNDGROUP *soundgroup, int index, FMOD_SOUND **sound)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetSound$address() {
        return FMOD_SoundGroup_GetSound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetSound(FMOD_SOUNDGROUP *soundgroup, int index, FMOD_SOUND **sound)
     * }
     */
    public static int FMOD_SoundGroup_GetSound(MemorySegment soundgroup, int index, MemorySegment sound) {
        var mh$ = FMOD_SoundGroup_GetSound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetSound", soundgroup, index, sound);
            }
            return (int)mh$.invokeExact(soundgroup, index, sound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetNumPlaying {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetNumPlaying");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumPlaying(FMOD_SOUNDGROUP *soundgroup, int *numplaying)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetNumPlaying$descriptor() {
        return FMOD_SoundGroup_GetNumPlaying.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumPlaying(FMOD_SOUNDGROUP *soundgroup, int *numplaying)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetNumPlaying$handle() {
        return FMOD_SoundGroup_GetNumPlaying.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumPlaying(FMOD_SOUNDGROUP *soundgroup, int *numplaying)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetNumPlaying$address() {
        return FMOD_SoundGroup_GetNumPlaying.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetNumPlaying(FMOD_SOUNDGROUP *soundgroup, int *numplaying)
     * }
     */
    public static int FMOD_SoundGroup_GetNumPlaying(MemorySegment soundgroup, MemorySegment numplaying) {
        var mh$ = FMOD_SoundGroup_GetNumPlaying.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetNumPlaying", soundgroup, numplaying);
            }
            return (int)mh$.invokeExact(soundgroup, numplaying);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetUserData(FMOD_SOUNDGROUP *soundgroup, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_SetUserData$descriptor() {
        return FMOD_SoundGroup_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetUserData(FMOD_SOUNDGROUP *soundgroup, void *userdata)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_SetUserData$handle() {
        return FMOD_SoundGroup_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetUserData(FMOD_SOUNDGROUP *soundgroup, void *userdata)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_SetUserData$address() {
        return FMOD_SoundGroup_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_SetUserData(FMOD_SOUNDGROUP *soundgroup, void *userdata)
     * }
     */
    public static int FMOD_SoundGroup_SetUserData(MemorySegment soundgroup, MemorySegment userdata) {
        var mh$ = FMOD_SoundGroup_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_SetUserData", soundgroup, userdata);
            }
            return (int)mh$.invokeExact(soundgroup, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_SoundGroup_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_SoundGroup_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetUserData(FMOD_SOUNDGROUP *soundgroup, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_SoundGroup_GetUserData$descriptor() {
        return FMOD_SoundGroup_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetUserData(FMOD_SOUNDGROUP *soundgroup, void **userdata)
     * }
     */
    public static MethodHandle FMOD_SoundGroup_GetUserData$handle() {
        return FMOD_SoundGroup_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetUserData(FMOD_SOUNDGROUP *soundgroup, void **userdata)
     * }
     */
    public static MemorySegment FMOD_SoundGroup_GetUserData$address() {
        return FMOD_SoundGroup_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_SoundGroup_GetUserData(FMOD_SOUNDGROUP *soundgroup, void **userdata)
     * }
     */
    public static int FMOD_SoundGroup_GetUserData(MemorySegment soundgroup, MemorySegment userdata) {
        var mh$ = FMOD_SoundGroup_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_SoundGroup_GetUserData", soundgroup, userdata);
            }
            return (int)mh$.invokeExact(soundgroup, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Release(FMOD_DSP *dsp)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_Release$descriptor() {
        return FMOD_DSP_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Release(FMOD_DSP *dsp)
     * }
     */
    public static MethodHandle FMOD_DSP_Release$handle() {
        return FMOD_DSP_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Release(FMOD_DSP *dsp)
     * }
     */
    public static MemorySegment FMOD_DSP_Release$address() {
        return FMOD_DSP_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Release(FMOD_DSP *dsp)
     * }
     */
    public static int FMOD_DSP_Release(MemorySegment dsp) {
        var mh$ = FMOD_DSP_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_Release", dsp);
            }
            return (int)mh$.invokeExact(dsp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetSystemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetSystemObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetSystemObject(FMOD_DSP *dsp, FMOD_SYSTEM **system)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetSystemObject$descriptor() {
        return FMOD_DSP_GetSystemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetSystemObject(FMOD_DSP *dsp, FMOD_SYSTEM **system)
     * }
     */
    public static MethodHandle FMOD_DSP_GetSystemObject$handle() {
        return FMOD_DSP_GetSystemObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetSystemObject(FMOD_DSP *dsp, FMOD_SYSTEM **system)
     * }
     */
    public static MemorySegment FMOD_DSP_GetSystemObject$address() {
        return FMOD_DSP_GetSystemObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetSystemObject(FMOD_DSP *dsp, FMOD_SYSTEM **system)
     * }
     */
    public static int FMOD_DSP_GetSystemObject(MemorySegment dsp, MemorySegment system) {
        var mh$ = FMOD_DSP_GetSystemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetSystemObject", dsp, system);
            }
            return (int)mh$.invokeExact(dsp, system);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_AddInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_AddInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_AddInput(FMOD_DSP *dsp, FMOD_DSP *input, FMOD_DSPCONNECTION **connection, FMOD_DSPCONNECTION_TYPE type)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_AddInput$descriptor() {
        return FMOD_DSP_AddInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_AddInput(FMOD_DSP *dsp, FMOD_DSP *input, FMOD_DSPCONNECTION **connection, FMOD_DSPCONNECTION_TYPE type)
     * }
     */
    public static MethodHandle FMOD_DSP_AddInput$handle() {
        return FMOD_DSP_AddInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_AddInput(FMOD_DSP *dsp, FMOD_DSP *input, FMOD_DSPCONNECTION **connection, FMOD_DSPCONNECTION_TYPE type)
     * }
     */
    public static MemorySegment FMOD_DSP_AddInput$address() {
        return FMOD_DSP_AddInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_AddInput(FMOD_DSP *dsp, FMOD_DSP *input, FMOD_DSPCONNECTION **connection, FMOD_DSPCONNECTION_TYPE type)
     * }
     */
    public static int FMOD_DSP_AddInput(MemorySegment dsp, MemorySegment input, MemorySegment connection, int type) {
        var mh$ = FMOD_DSP_AddInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_AddInput", dsp, input, connection, type);
            }
            return (int)mh$.invokeExact(dsp, input, connection, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_DisconnectFrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_DisconnectFrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectFrom(FMOD_DSP *dsp, FMOD_DSP *target, FMOD_DSPCONNECTION *connection)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_DisconnectFrom$descriptor() {
        return FMOD_DSP_DisconnectFrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectFrom(FMOD_DSP *dsp, FMOD_DSP *target, FMOD_DSPCONNECTION *connection)
     * }
     */
    public static MethodHandle FMOD_DSP_DisconnectFrom$handle() {
        return FMOD_DSP_DisconnectFrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectFrom(FMOD_DSP *dsp, FMOD_DSP *target, FMOD_DSPCONNECTION *connection)
     * }
     */
    public static MemorySegment FMOD_DSP_DisconnectFrom$address() {
        return FMOD_DSP_DisconnectFrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectFrom(FMOD_DSP *dsp, FMOD_DSP *target, FMOD_DSPCONNECTION *connection)
     * }
     */
    public static int FMOD_DSP_DisconnectFrom(MemorySegment dsp, MemorySegment target, MemorySegment connection) {
        var mh$ = FMOD_DSP_DisconnectFrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_DisconnectFrom", dsp, target, connection);
            }
            return (int)mh$.invokeExact(dsp, target, connection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_DisconnectAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_DisconnectAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectAll(FMOD_DSP *dsp, FMOD_BOOL inputs, FMOD_BOOL outputs)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_DisconnectAll$descriptor() {
        return FMOD_DSP_DisconnectAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectAll(FMOD_DSP *dsp, FMOD_BOOL inputs, FMOD_BOOL outputs)
     * }
     */
    public static MethodHandle FMOD_DSP_DisconnectAll$handle() {
        return FMOD_DSP_DisconnectAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectAll(FMOD_DSP *dsp, FMOD_BOOL inputs, FMOD_BOOL outputs)
     * }
     */
    public static MemorySegment FMOD_DSP_DisconnectAll$address() {
        return FMOD_DSP_DisconnectAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_DisconnectAll(FMOD_DSP *dsp, FMOD_BOOL inputs, FMOD_BOOL outputs)
     * }
     */
    public static int FMOD_DSP_DisconnectAll(MemorySegment dsp, int inputs, int outputs) {
        var mh$ = FMOD_DSP_DisconnectAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_DisconnectAll", dsp, inputs, outputs);
            }
            return (int)mh$.invokeExact(dsp, inputs, outputs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetNumInputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetNumInputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumInputs(FMOD_DSP *dsp, int *numinputs)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetNumInputs$descriptor() {
        return FMOD_DSP_GetNumInputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumInputs(FMOD_DSP *dsp, int *numinputs)
     * }
     */
    public static MethodHandle FMOD_DSP_GetNumInputs$handle() {
        return FMOD_DSP_GetNumInputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumInputs(FMOD_DSP *dsp, int *numinputs)
     * }
     */
    public static MemorySegment FMOD_DSP_GetNumInputs$address() {
        return FMOD_DSP_GetNumInputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumInputs(FMOD_DSP *dsp, int *numinputs)
     * }
     */
    public static int FMOD_DSP_GetNumInputs(MemorySegment dsp, MemorySegment numinputs) {
        var mh$ = FMOD_DSP_GetNumInputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetNumInputs", dsp, numinputs);
            }
            return (int)mh$.invokeExact(dsp, numinputs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetNumOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetNumOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumOutputs(FMOD_DSP *dsp, int *numoutputs)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetNumOutputs$descriptor() {
        return FMOD_DSP_GetNumOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumOutputs(FMOD_DSP *dsp, int *numoutputs)
     * }
     */
    public static MethodHandle FMOD_DSP_GetNumOutputs$handle() {
        return FMOD_DSP_GetNumOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumOutputs(FMOD_DSP *dsp, int *numoutputs)
     * }
     */
    public static MemorySegment FMOD_DSP_GetNumOutputs$address() {
        return FMOD_DSP_GetNumOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumOutputs(FMOD_DSP *dsp, int *numoutputs)
     * }
     */
    public static int FMOD_DSP_GetNumOutputs(MemorySegment dsp, MemorySegment numoutputs) {
        var mh$ = FMOD_DSP_GetNumOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetNumOutputs", dsp, numoutputs);
            }
            return (int)mh$.invokeExact(dsp, numoutputs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInput(FMOD_DSP *dsp, int index, FMOD_DSP **input, FMOD_DSPCONNECTION **inputconnection)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetInput$descriptor() {
        return FMOD_DSP_GetInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInput(FMOD_DSP *dsp, int index, FMOD_DSP **input, FMOD_DSPCONNECTION **inputconnection)
     * }
     */
    public static MethodHandle FMOD_DSP_GetInput$handle() {
        return FMOD_DSP_GetInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInput(FMOD_DSP *dsp, int index, FMOD_DSP **input, FMOD_DSPCONNECTION **inputconnection)
     * }
     */
    public static MemorySegment FMOD_DSP_GetInput$address() {
        return FMOD_DSP_GetInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInput(FMOD_DSP *dsp, int index, FMOD_DSP **input, FMOD_DSPCONNECTION **inputconnection)
     * }
     */
    public static int FMOD_DSP_GetInput(MemorySegment dsp, int index, MemorySegment input, MemorySegment inputconnection) {
        var mh$ = FMOD_DSP_GetInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetInput", dsp, index, input, inputconnection);
            }
            return (int)mh$.invokeExact(dsp, index, input, inputconnection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutput(FMOD_DSP *dsp, int index, FMOD_DSP **output, FMOD_DSPCONNECTION **outputconnection)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetOutput$descriptor() {
        return FMOD_DSP_GetOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutput(FMOD_DSP *dsp, int index, FMOD_DSP **output, FMOD_DSPCONNECTION **outputconnection)
     * }
     */
    public static MethodHandle FMOD_DSP_GetOutput$handle() {
        return FMOD_DSP_GetOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutput(FMOD_DSP *dsp, int index, FMOD_DSP **output, FMOD_DSPCONNECTION **outputconnection)
     * }
     */
    public static MemorySegment FMOD_DSP_GetOutput$address() {
        return FMOD_DSP_GetOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutput(FMOD_DSP *dsp, int index, FMOD_DSP **output, FMOD_DSPCONNECTION **outputconnection)
     * }
     */
    public static int FMOD_DSP_GetOutput(MemorySegment dsp, int index, MemorySegment output, MemorySegment outputconnection) {
        var mh$ = FMOD_DSP_GetOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetOutput", dsp, index, output, outputconnection);
            }
            return (int)mh$.invokeExact(dsp, index, output, outputconnection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetActive(FMOD_DSP *dsp, FMOD_BOOL active)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetActive$descriptor() {
        return FMOD_DSP_SetActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetActive(FMOD_DSP *dsp, FMOD_BOOL active)
     * }
     */
    public static MethodHandle FMOD_DSP_SetActive$handle() {
        return FMOD_DSP_SetActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetActive(FMOD_DSP *dsp, FMOD_BOOL active)
     * }
     */
    public static MemorySegment FMOD_DSP_SetActive$address() {
        return FMOD_DSP_SetActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetActive(FMOD_DSP *dsp, FMOD_BOOL active)
     * }
     */
    public static int FMOD_DSP_SetActive(MemorySegment dsp, int active) {
        var mh$ = FMOD_DSP_SetActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetActive", dsp, active);
            }
            return (int)mh$.invokeExact(dsp, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetActive(FMOD_DSP *dsp, FMOD_BOOL *active)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetActive$descriptor() {
        return FMOD_DSP_GetActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetActive(FMOD_DSP *dsp, FMOD_BOOL *active)
     * }
     */
    public static MethodHandle FMOD_DSP_GetActive$handle() {
        return FMOD_DSP_GetActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetActive(FMOD_DSP *dsp, FMOD_BOOL *active)
     * }
     */
    public static MemorySegment FMOD_DSP_GetActive$address() {
        return FMOD_DSP_GetActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetActive(FMOD_DSP *dsp, FMOD_BOOL *active)
     * }
     */
    public static int FMOD_DSP_GetActive(MemorySegment dsp, MemorySegment active) {
        var mh$ = FMOD_DSP_GetActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetActive", dsp, active);
            }
            return (int)mh$.invokeExact(dsp, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetBypass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetBypass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetBypass(FMOD_DSP *dsp, FMOD_BOOL bypass)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetBypass$descriptor() {
        return FMOD_DSP_SetBypass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetBypass(FMOD_DSP *dsp, FMOD_BOOL bypass)
     * }
     */
    public static MethodHandle FMOD_DSP_SetBypass$handle() {
        return FMOD_DSP_SetBypass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetBypass(FMOD_DSP *dsp, FMOD_BOOL bypass)
     * }
     */
    public static MemorySegment FMOD_DSP_SetBypass$address() {
        return FMOD_DSP_SetBypass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetBypass(FMOD_DSP *dsp, FMOD_BOOL bypass)
     * }
     */
    public static int FMOD_DSP_SetBypass(MemorySegment dsp, int bypass) {
        var mh$ = FMOD_DSP_SetBypass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetBypass", dsp, bypass);
            }
            return (int)mh$.invokeExact(dsp, bypass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetBypass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetBypass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetBypass(FMOD_DSP *dsp, FMOD_BOOL *bypass)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetBypass$descriptor() {
        return FMOD_DSP_GetBypass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetBypass(FMOD_DSP *dsp, FMOD_BOOL *bypass)
     * }
     */
    public static MethodHandle FMOD_DSP_GetBypass$handle() {
        return FMOD_DSP_GetBypass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetBypass(FMOD_DSP *dsp, FMOD_BOOL *bypass)
     * }
     */
    public static MemorySegment FMOD_DSP_GetBypass$address() {
        return FMOD_DSP_GetBypass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetBypass(FMOD_DSP *dsp, FMOD_BOOL *bypass)
     * }
     */
    public static int FMOD_DSP_GetBypass(MemorySegment dsp, MemorySegment bypass) {
        var mh$ = FMOD_DSP_GetBypass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetBypass", dsp, bypass);
            }
            return (int)mh$.invokeExact(dsp, bypass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetWetDryMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetWetDryMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetWetDryMix(FMOD_DSP *dsp, float prewet, float postwet, float dry)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetWetDryMix$descriptor() {
        return FMOD_DSP_SetWetDryMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetWetDryMix(FMOD_DSP *dsp, float prewet, float postwet, float dry)
     * }
     */
    public static MethodHandle FMOD_DSP_SetWetDryMix$handle() {
        return FMOD_DSP_SetWetDryMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetWetDryMix(FMOD_DSP *dsp, float prewet, float postwet, float dry)
     * }
     */
    public static MemorySegment FMOD_DSP_SetWetDryMix$address() {
        return FMOD_DSP_SetWetDryMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetWetDryMix(FMOD_DSP *dsp, float prewet, float postwet, float dry)
     * }
     */
    public static int FMOD_DSP_SetWetDryMix(MemorySegment dsp, float prewet, float postwet, float dry) {
        var mh$ = FMOD_DSP_SetWetDryMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetWetDryMix", dsp, prewet, postwet, dry);
            }
            return (int)mh$.invokeExact(dsp, prewet, postwet, dry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetWetDryMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetWetDryMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetWetDryMix(FMOD_DSP *dsp, float *prewet, float *postwet, float *dry)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetWetDryMix$descriptor() {
        return FMOD_DSP_GetWetDryMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetWetDryMix(FMOD_DSP *dsp, float *prewet, float *postwet, float *dry)
     * }
     */
    public static MethodHandle FMOD_DSP_GetWetDryMix$handle() {
        return FMOD_DSP_GetWetDryMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetWetDryMix(FMOD_DSP *dsp, float *prewet, float *postwet, float *dry)
     * }
     */
    public static MemorySegment FMOD_DSP_GetWetDryMix$address() {
        return FMOD_DSP_GetWetDryMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetWetDryMix(FMOD_DSP *dsp, float *prewet, float *postwet, float *dry)
     * }
     */
    public static int FMOD_DSP_GetWetDryMix(MemorySegment dsp, MemorySegment prewet, MemorySegment postwet, MemorySegment dry) {
        var mh$ = FMOD_DSP_GetWetDryMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetWetDryMix", dsp, prewet, postwet, dry);
            }
            return (int)mh$.invokeExact(dsp, prewet, postwet, dry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetChannelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetChannelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK channelmask, int numchannels, FMOD_SPEAKERMODE source_speakermode)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetChannelFormat$descriptor() {
        return FMOD_DSP_SetChannelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK channelmask, int numchannels, FMOD_SPEAKERMODE source_speakermode)
     * }
     */
    public static MethodHandle FMOD_DSP_SetChannelFormat$handle() {
        return FMOD_DSP_SetChannelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK channelmask, int numchannels, FMOD_SPEAKERMODE source_speakermode)
     * }
     */
    public static MemorySegment FMOD_DSP_SetChannelFormat$address() {
        return FMOD_DSP_SetChannelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK channelmask, int numchannels, FMOD_SPEAKERMODE source_speakermode)
     * }
     */
    public static int FMOD_DSP_SetChannelFormat(MemorySegment dsp, int channelmask, int numchannels, int source_speakermode) {
        var mh$ = FMOD_DSP_SetChannelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetChannelFormat", dsp, channelmask, numchannels, source_speakermode);
            }
            return (int)mh$.invokeExact(dsp, channelmask, numchannels, source_speakermode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetChannelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetChannelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK *channelmask, int *numchannels, FMOD_SPEAKERMODE *source_speakermode)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetChannelFormat$descriptor() {
        return FMOD_DSP_GetChannelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK *channelmask, int *numchannels, FMOD_SPEAKERMODE *source_speakermode)
     * }
     */
    public static MethodHandle FMOD_DSP_GetChannelFormat$handle() {
        return FMOD_DSP_GetChannelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK *channelmask, int *numchannels, FMOD_SPEAKERMODE *source_speakermode)
     * }
     */
    public static MemorySegment FMOD_DSP_GetChannelFormat$address() {
        return FMOD_DSP_GetChannelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK *channelmask, int *numchannels, FMOD_SPEAKERMODE *source_speakermode)
     * }
     */
    public static int FMOD_DSP_GetChannelFormat(MemorySegment dsp, MemorySegment channelmask, MemorySegment numchannels, MemorySegment source_speakermode) {
        var mh$ = FMOD_DSP_GetChannelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetChannelFormat", dsp, channelmask, numchannels, source_speakermode);
            }
            return (int)mh$.invokeExact(dsp, channelmask, numchannels, source_speakermode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetOutputChannelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetOutputChannelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutputChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK inmask, int inchannels, FMOD_SPEAKERMODE inspeakermode, FMOD_CHANNELMASK *outmask, int *outchannels, FMOD_SPEAKERMODE *outspeakermode)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetOutputChannelFormat$descriptor() {
        return FMOD_DSP_GetOutputChannelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutputChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK inmask, int inchannels, FMOD_SPEAKERMODE inspeakermode, FMOD_CHANNELMASK *outmask, int *outchannels, FMOD_SPEAKERMODE *outspeakermode)
     * }
     */
    public static MethodHandle FMOD_DSP_GetOutputChannelFormat$handle() {
        return FMOD_DSP_GetOutputChannelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutputChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK inmask, int inchannels, FMOD_SPEAKERMODE inspeakermode, FMOD_CHANNELMASK *outmask, int *outchannels, FMOD_SPEAKERMODE *outspeakermode)
     * }
     */
    public static MemorySegment FMOD_DSP_GetOutputChannelFormat$address() {
        return FMOD_DSP_GetOutputChannelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetOutputChannelFormat(FMOD_DSP *dsp, FMOD_CHANNELMASK inmask, int inchannels, FMOD_SPEAKERMODE inspeakermode, FMOD_CHANNELMASK *outmask, int *outchannels, FMOD_SPEAKERMODE *outspeakermode)
     * }
     */
    public static int FMOD_DSP_GetOutputChannelFormat(MemorySegment dsp, int inmask, int inchannels, int inspeakermode, MemorySegment outmask, MemorySegment outchannels, MemorySegment outspeakermode) {
        var mh$ = FMOD_DSP_GetOutputChannelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetOutputChannelFormat", dsp, inmask, inchannels, inspeakermode, outmask, outchannels, outspeakermode);
            }
            return (int)mh$.invokeExact(dsp, inmask, inchannels, inspeakermode, outmask, outchannels, outspeakermode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_Reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_Reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Reset(FMOD_DSP *dsp)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_Reset$descriptor() {
        return FMOD_DSP_Reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Reset(FMOD_DSP *dsp)
     * }
     */
    public static MethodHandle FMOD_DSP_Reset$handle() {
        return FMOD_DSP_Reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Reset(FMOD_DSP *dsp)
     * }
     */
    public static MemorySegment FMOD_DSP_Reset$address() {
        return FMOD_DSP_Reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_Reset(FMOD_DSP *dsp)
     * }
     */
    public static int FMOD_DSP_Reset(MemorySegment dsp) {
        var mh$ = FMOD_DSP_Reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_Reset", dsp);
            }
            return (int)mh$.invokeExact(dsp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetCallback(FMOD_DSP *dsp, FMOD_DSP_CALLBACK callback)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetCallback$descriptor() {
        return FMOD_DSP_SetCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetCallback(FMOD_DSP *dsp, FMOD_DSP_CALLBACK callback)
     * }
     */
    public static MethodHandle FMOD_DSP_SetCallback$handle() {
        return FMOD_DSP_SetCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetCallback(FMOD_DSP *dsp, FMOD_DSP_CALLBACK callback)
     * }
     */
    public static MemorySegment FMOD_DSP_SetCallback$address() {
        return FMOD_DSP_SetCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetCallback(FMOD_DSP *dsp, FMOD_DSP_CALLBACK callback)
     * }
     */
    public static int FMOD_DSP_SetCallback(MemorySegment dsp, MemorySegment callback) {
        var mh$ = FMOD_DSP_SetCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetCallback", dsp, callback);
            }
            return (int)mh$.invokeExact(dsp, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetParameterFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetParameterFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterFloat(FMOD_DSP *dsp, int index, float value)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetParameterFloat$descriptor() {
        return FMOD_DSP_SetParameterFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterFloat(FMOD_DSP *dsp, int index, float value)
     * }
     */
    public static MethodHandle FMOD_DSP_SetParameterFloat$handle() {
        return FMOD_DSP_SetParameterFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterFloat(FMOD_DSP *dsp, int index, float value)
     * }
     */
    public static MemorySegment FMOD_DSP_SetParameterFloat$address() {
        return FMOD_DSP_SetParameterFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterFloat(FMOD_DSP *dsp, int index, float value)
     * }
     */
    public static int FMOD_DSP_SetParameterFloat(MemorySegment dsp, int index, float value) {
        var mh$ = FMOD_DSP_SetParameterFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetParameterFloat", dsp, index, value);
            }
            return (int)mh$.invokeExact(dsp, index, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetParameterInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetParameterInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterInt(FMOD_DSP *dsp, int index, int value)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetParameterInt$descriptor() {
        return FMOD_DSP_SetParameterInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterInt(FMOD_DSP *dsp, int index, int value)
     * }
     */
    public static MethodHandle FMOD_DSP_SetParameterInt$handle() {
        return FMOD_DSP_SetParameterInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterInt(FMOD_DSP *dsp, int index, int value)
     * }
     */
    public static MemorySegment FMOD_DSP_SetParameterInt$address() {
        return FMOD_DSP_SetParameterInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterInt(FMOD_DSP *dsp, int index, int value)
     * }
     */
    public static int FMOD_DSP_SetParameterInt(MemorySegment dsp, int index, int value) {
        var mh$ = FMOD_DSP_SetParameterInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetParameterInt", dsp, index, value);
            }
            return (int)mh$.invokeExact(dsp, index, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetParameterBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetParameterBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL value)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetParameterBool$descriptor() {
        return FMOD_DSP_SetParameterBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL value)
     * }
     */
    public static MethodHandle FMOD_DSP_SetParameterBool$handle() {
        return FMOD_DSP_SetParameterBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL value)
     * }
     */
    public static MemorySegment FMOD_DSP_SetParameterBool$address() {
        return FMOD_DSP_SetParameterBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL value)
     * }
     */
    public static int FMOD_DSP_SetParameterBool(MemorySegment dsp, int index, int value) {
        var mh$ = FMOD_DSP_SetParameterBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetParameterBool", dsp, index, value);
            }
            return (int)mh$.invokeExact(dsp, index, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetParameterData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetParameterData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterData(FMOD_DSP *dsp, int index, void *data, unsigned int length)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetParameterData$descriptor() {
        return FMOD_DSP_SetParameterData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterData(FMOD_DSP *dsp, int index, void *data, unsigned int length)
     * }
     */
    public static MethodHandle FMOD_DSP_SetParameterData$handle() {
        return FMOD_DSP_SetParameterData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterData(FMOD_DSP *dsp, int index, void *data, unsigned int length)
     * }
     */
    public static MemorySegment FMOD_DSP_SetParameterData$address() {
        return FMOD_DSP_SetParameterData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetParameterData(FMOD_DSP *dsp, int index, void *data, unsigned int length)
     * }
     */
    public static int FMOD_DSP_SetParameterData(MemorySegment dsp, int index, MemorySegment data, int length) {
        var mh$ = FMOD_DSP_SetParameterData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetParameterData", dsp, index, data, length);
            }
            return (int)mh$.invokeExact(dsp, index, data, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetParameterFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetParameterFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterFloat(FMOD_DSP *dsp, int index, float *value, char *valuestr, int valuestrlen)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetParameterFloat$descriptor() {
        return FMOD_DSP_GetParameterFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterFloat(FMOD_DSP *dsp, int index, float *value, char *valuestr, int valuestrlen)
     * }
     */
    public static MethodHandle FMOD_DSP_GetParameterFloat$handle() {
        return FMOD_DSP_GetParameterFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterFloat(FMOD_DSP *dsp, int index, float *value, char *valuestr, int valuestrlen)
     * }
     */
    public static MemorySegment FMOD_DSP_GetParameterFloat$address() {
        return FMOD_DSP_GetParameterFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterFloat(FMOD_DSP *dsp, int index, float *value, char *valuestr, int valuestrlen)
     * }
     */
    public static int FMOD_DSP_GetParameterFloat(MemorySegment dsp, int index, MemorySegment value, MemorySegment valuestr, int valuestrlen) {
        var mh$ = FMOD_DSP_GetParameterFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetParameterFloat", dsp, index, value, valuestr, valuestrlen);
            }
            return (int)mh$.invokeExact(dsp, index, value, valuestr, valuestrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetParameterInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetParameterInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInt(FMOD_DSP *dsp, int index, int *value, char *valuestr, int valuestrlen)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetParameterInt$descriptor() {
        return FMOD_DSP_GetParameterInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInt(FMOD_DSP *dsp, int index, int *value, char *valuestr, int valuestrlen)
     * }
     */
    public static MethodHandle FMOD_DSP_GetParameterInt$handle() {
        return FMOD_DSP_GetParameterInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInt(FMOD_DSP *dsp, int index, int *value, char *valuestr, int valuestrlen)
     * }
     */
    public static MemorySegment FMOD_DSP_GetParameterInt$address() {
        return FMOD_DSP_GetParameterInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInt(FMOD_DSP *dsp, int index, int *value, char *valuestr, int valuestrlen)
     * }
     */
    public static int FMOD_DSP_GetParameterInt(MemorySegment dsp, int index, MemorySegment value, MemorySegment valuestr, int valuestrlen) {
        var mh$ = FMOD_DSP_GetParameterInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetParameterInt", dsp, index, value, valuestr, valuestrlen);
            }
            return (int)mh$.invokeExact(dsp, index, value, valuestr, valuestrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetParameterBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetParameterBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL *value, char *valuestr, int valuestrlen)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetParameterBool$descriptor() {
        return FMOD_DSP_GetParameterBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL *value, char *valuestr, int valuestrlen)
     * }
     */
    public static MethodHandle FMOD_DSP_GetParameterBool$handle() {
        return FMOD_DSP_GetParameterBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL *value, char *valuestr, int valuestrlen)
     * }
     */
    public static MemorySegment FMOD_DSP_GetParameterBool$address() {
        return FMOD_DSP_GetParameterBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterBool(FMOD_DSP *dsp, int index, FMOD_BOOL *value, char *valuestr, int valuestrlen)
     * }
     */
    public static int FMOD_DSP_GetParameterBool(MemorySegment dsp, int index, MemorySegment value, MemorySegment valuestr, int valuestrlen) {
        var mh$ = FMOD_DSP_GetParameterBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetParameterBool", dsp, index, value, valuestr, valuestrlen);
            }
            return (int)mh$.invokeExact(dsp, index, value, valuestr, valuestrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetParameterData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetParameterData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterData(FMOD_DSP *dsp, int index, void **data, unsigned int *length, char *valuestr, int valuestrlen)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetParameterData$descriptor() {
        return FMOD_DSP_GetParameterData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterData(FMOD_DSP *dsp, int index, void **data, unsigned int *length, char *valuestr, int valuestrlen)
     * }
     */
    public static MethodHandle FMOD_DSP_GetParameterData$handle() {
        return FMOD_DSP_GetParameterData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterData(FMOD_DSP *dsp, int index, void **data, unsigned int *length, char *valuestr, int valuestrlen)
     * }
     */
    public static MemorySegment FMOD_DSP_GetParameterData$address() {
        return FMOD_DSP_GetParameterData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterData(FMOD_DSP *dsp, int index, void **data, unsigned int *length, char *valuestr, int valuestrlen)
     * }
     */
    public static int FMOD_DSP_GetParameterData(MemorySegment dsp, int index, MemorySegment data, MemorySegment length, MemorySegment valuestr, int valuestrlen) {
        var mh$ = FMOD_DSP_GetParameterData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetParameterData", dsp, index, data, length, valuestr, valuestrlen);
            }
            return (int)mh$.invokeExact(dsp, index, data, length, valuestr, valuestrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetNumParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetNumParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumParameters(FMOD_DSP *dsp, int *numparams)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetNumParameters$descriptor() {
        return FMOD_DSP_GetNumParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumParameters(FMOD_DSP *dsp, int *numparams)
     * }
     */
    public static MethodHandle FMOD_DSP_GetNumParameters$handle() {
        return FMOD_DSP_GetNumParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumParameters(FMOD_DSP *dsp, int *numparams)
     * }
     */
    public static MemorySegment FMOD_DSP_GetNumParameters$address() {
        return FMOD_DSP_GetNumParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetNumParameters(FMOD_DSP *dsp, int *numparams)
     * }
     */
    public static int FMOD_DSP_GetNumParameters(MemorySegment dsp, MemorySegment numparams) {
        var mh$ = FMOD_DSP_GetNumParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetNumParameters", dsp, numparams);
            }
            return (int)mh$.invokeExact(dsp, numparams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetParameterInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetParameterInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInfo(FMOD_DSP *dsp, int index, FMOD_DSP_PARAMETER_DESC **desc)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetParameterInfo$descriptor() {
        return FMOD_DSP_GetParameterInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInfo(FMOD_DSP *dsp, int index, FMOD_DSP_PARAMETER_DESC **desc)
     * }
     */
    public static MethodHandle FMOD_DSP_GetParameterInfo$handle() {
        return FMOD_DSP_GetParameterInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInfo(FMOD_DSP *dsp, int index, FMOD_DSP_PARAMETER_DESC **desc)
     * }
     */
    public static MemorySegment FMOD_DSP_GetParameterInfo$address() {
        return FMOD_DSP_GetParameterInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetParameterInfo(FMOD_DSP *dsp, int index, FMOD_DSP_PARAMETER_DESC **desc)
     * }
     */
    public static int FMOD_DSP_GetParameterInfo(MemorySegment dsp, int index, MemorySegment desc) {
        var mh$ = FMOD_DSP_GetParameterInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetParameterInfo", dsp, index, desc);
            }
            return (int)mh$.invokeExact(dsp, index, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetDataParameterIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetDataParameterIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetDataParameterIndex(FMOD_DSP *dsp, int datatype, int *index)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetDataParameterIndex$descriptor() {
        return FMOD_DSP_GetDataParameterIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetDataParameterIndex(FMOD_DSP *dsp, int datatype, int *index)
     * }
     */
    public static MethodHandle FMOD_DSP_GetDataParameterIndex$handle() {
        return FMOD_DSP_GetDataParameterIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetDataParameterIndex(FMOD_DSP *dsp, int datatype, int *index)
     * }
     */
    public static MemorySegment FMOD_DSP_GetDataParameterIndex$address() {
        return FMOD_DSP_GetDataParameterIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetDataParameterIndex(FMOD_DSP *dsp, int datatype, int *index)
     * }
     */
    public static int FMOD_DSP_GetDataParameterIndex(MemorySegment dsp, int datatype, MemorySegment index) {
        var mh$ = FMOD_DSP_GetDataParameterIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetDataParameterIndex", dsp, datatype, index);
            }
            return (int)mh$.invokeExact(dsp, datatype, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_ShowConfigDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_ShowConfigDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_ShowConfigDialog(FMOD_DSP *dsp, void *hwnd, FMOD_BOOL show)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_ShowConfigDialog$descriptor() {
        return FMOD_DSP_ShowConfigDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_ShowConfigDialog(FMOD_DSP *dsp, void *hwnd, FMOD_BOOL show)
     * }
     */
    public static MethodHandle FMOD_DSP_ShowConfigDialog$handle() {
        return FMOD_DSP_ShowConfigDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_ShowConfigDialog(FMOD_DSP *dsp, void *hwnd, FMOD_BOOL show)
     * }
     */
    public static MemorySegment FMOD_DSP_ShowConfigDialog$address() {
        return FMOD_DSP_ShowConfigDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_ShowConfigDialog(FMOD_DSP *dsp, void *hwnd, FMOD_BOOL show)
     * }
     */
    public static int FMOD_DSP_ShowConfigDialog(MemorySegment dsp, MemorySegment hwnd, int show) {
        var mh$ = FMOD_DSP_ShowConfigDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_ShowConfigDialog", dsp, hwnd, show);
            }
            return (int)mh$.invokeExact(dsp, hwnd, show);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInfo(FMOD_DSP *dsp, char *name, unsigned int *version, int *channels, int *configwidth, int *configheight)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetInfo$descriptor() {
        return FMOD_DSP_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInfo(FMOD_DSP *dsp, char *name, unsigned int *version, int *channels, int *configwidth, int *configheight)
     * }
     */
    public static MethodHandle FMOD_DSP_GetInfo$handle() {
        return FMOD_DSP_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInfo(FMOD_DSP *dsp, char *name, unsigned int *version, int *channels, int *configwidth, int *configheight)
     * }
     */
    public static MemorySegment FMOD_DSP_GetInfo$address() {
        return FMOD_DSP_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetInfo(FMOD_DSP *dsp, char *name, unsigned int *version, int *channels, int *configwidth, int *configheight)
     * }
     */
    public static int FMOD_DSP_GetInfo(MemorySegment dsp, MemorySegment name, MemorySegment version, MemorySegment channels, MemorySegment configwidth, MemorySegment configheight) {
        var mh$ = FMOD_DSP_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetInfo", dsp, name, version, channels, configwidth, configheight);
            }
            return (int)mh$.invokeExact(dsp, name, version, channels, configwidth, configheight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetType(FMOD_DSP *dsp, FMOD_DSP_TYPE *type)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetType$descriptor() {
        return FMOD_DSP_GetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetType(FMOD_DSP *dsp, FMOD_DSP_TYPE *type)
     * }
     */
    public static MethodHandle FMOD_DSP_GetType$handle() {
        return FMOD_DSP_GetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetType(FMOD_DSP *dsp, FMOD_DSP_TYPE *type)
     * }
     */
    public static MemorySegment FMOD_DSP_GetType$address() {
        return FMOD_DSP_GetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetType(FMOD_DSP *dsp, FMOD_DSP_TYPE *type)
     * }
     */
    public static int FMOD_DSP_GetType(MemorySegment dsp, MemorySegment type) {
        var mh$ = FMOD_DSP_GetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetType", dsp, type);
            }
            return (int)mh$.invokeExact(dsp, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetIdle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetIdle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetIdle(FMOD_DSP *dsp, FMOD_BOOL *idle)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetIdle$descriptor() {
        return FMOD_DSP_GetIdle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetIdle(FMOD_DSP *dsp, FMOD_BOOL *idle)
     * }
     */
    public static MethodHandle FMOD_DSP_GetIdle$handle() {
        return FMOD_DSP_GetIdle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetIdle(FMOD_DSP *dsp, FMOD_BOOL *idle)
     * }
     */
    public static MemorySegment FMOD_DSP_GetIdle$address() {
        return FMOD_DSP_GetIdle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetIdle(FMOD_DSP *dsp, FMOD_BOOL *idle)
     * }
     */
    public static int FMOD_DSP_GetIdle(MemorySegment dsp, MemorySegment idle) {
        var mh$ = FMOD_DSP_GetIdle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetIdle", dsp, idle);
            }
            return (int)mh$.invokeExact(dsp, idle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetUserData(FMOD_DSP *dsp, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetUserData$descriptor() {
        return FMOD_DSP_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetUserData(FMOD_DSP *dsp, void *userdata)
     * }
     */
    public static MethodHandle FMOD_DSP_SetUserData$handle() {
        return FMOD_DSP_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetUserData(FMOD_DSP *dsp, void *userdata)
     * }
     */
    public static MemorySegment FMOD_DSP_SetUserData$address() {
        return FMOD_DSP_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetUserData(FMOD_DSP *dsp, void *userdata)
     * }
     */
    public static int FMOD_DSP_SetUserData(MemorySegment dsp, MemorySegment userdata) {
        var mh$ = FMOD_DSP_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetUserData", dsp, userdata);
            }
            return (int)mh$.invokeExact(dsp, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetUserData(FMOD_DSP *dsp, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetUserData$descriptor() {
        return FMOD_DSP_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetUserData(FMOD_DSP *dsp, void **userdata)
     * }
     */
    public static MethodHandle FMOD_DSP_GetUserData$handle() {
        return FMOD_DSP_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetUserData(FMOD_DSP *dsp, void **userdata)
     * }
     */
    public static MemorySegment FMOD_DSP_GetUserData$address() {
        return FMOD_DSP_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetUserData(FMOD_DSP *dsp, void **userdata)
     * }
     */
    public static int FMOD_DSP_GetUserData(MemorySegment dsp, MemorySegment userdata) {
        var mh$ = FMOD_DSP_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetUserData", dsp, userdata);
            }
            return (int)mh$.invokeExact(dsp, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_SetMeteringEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_SetMeteringEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL inputEnabled, FMOD_BOOL outputEnabled)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_SetMeteringEnabled$descriptor() {
        return FMOD_DSP_SetMeteringEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL inputEnabled, FMOD_BOOL outputEnabled)
     * }
     */
    public static MethodHandle FMOD_DSP_SetMeteringEnabled$handle() {
        return FMOD_DSP_SetMeteringEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL inputEnabled, FMOD_BOOL outputEnabled)
     * }
     */
    public static MemorySegment FMOD_DSP_SetMeteringEnabled$address() {
        return FMOD_DSP_SetMeteringEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_SetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL inputEnabled, FMOD_BOOL outputEnabled)
     * }
     */
    public static int FMOD_DSP_SetMeteringEnabled(MemorySegment dsp, int inputEnabled, int outputEnabled) {
        var mh$ = FMOD_DSP_SetMeteringEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_SetMeteringEnabled", dsp, inputEnabled, outputEnabled);
            }
            return (int)mh$.invokeExact(dsp, inputEnabled, outputEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetMeteringEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetMeteringEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL *inputEnabled, FMOD_BOOL *outputEnabled)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetMeteringEnabled$descriptor() {
        return FMOD_DSP_GetMeteringEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL *inputEnabled, FMOD_BOOL *outputEnabled)
     * }
     */
    public static MethodHandle FMOD_DSP_GetMeteringEnabled$handle() {
        return FMOD_DSP_GetMeteringEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL *inputEnabled, FMOD_BOOL *outputEnabled)
     * }
     */
    public static MemorySegment FMOD_DSP_GetMeteringEnabled$address() {
        return FMOD_DSP_GetMeteringEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringEnabled(FMOD_DSP *dsp, FMOD_BOOL *inputEnabled, FMOD_BOOL *outputEnabled)
     * }
     */
    public static int FMOD_DSP_GetMeteringEnabled(MemorySegment dsp, MemorySegment inputEnabled, MemorySegment outputEnabled) {
        var mh$ = FMOD_DSP_GetMeteringEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetMeteringEnabled", dsp, inputEnabled, outputEnabled);
            }
            return (int)mh$.invokeExact(dsp, inputEnabled, outputEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetMeteringInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetMeteringInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringInfo(FMOD_DSP *dsp, FMOD_DSP_METERING_INFO *inputInfo, FMOD_DSP_METERING_INFO *outputInfo)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetMeteringInfo$descriptor() {
        return FMOD_DSP_GetMeteringInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringInfo(FMOD_DSP *dsp, FMOD_DSP_METERING_INFO *inputInfo, FMOD_DSP_METERING_INFO *outputInfo)
     * }
     */
    public static MethodHandle FMOD_DSP_GetMeteringInfo$handle() {
        return FMOD_DSP_GetMeteringInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringInfo(FMOD_DSP *dsp, FMOD_DSP_METERING_INFO *inputInfo, FMOD_DSP_METERING_INFO *outputInfo)
     * }
     */
    public static MemorySegment FMOD_DSP_GetMeteringInfo$address() {
        return FMOD_DSP_GetMeteringInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetMeteringInfo(FMOD_DSP *dsp, FMOD_DSP_METERING_INFO *inputInfo, FMOD_DSP_METERING_INFO *outputInfo)
     * }
     */
    public static int FMOD_DSP_GetMeteringInfo(MemorySegment dsp, MemorySegment inputInfo, MemorySegment outputInfo) {
        var mh$ = FMOD_DSP_GetMeteringInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetMeteringInfo", dsp, inputInfo, outputInfo);
            }
            return (int)mh$.invokeExact(dsp, inputInfo, outputInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSP_GetCPUUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSP_GetCPUUsage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetCPUUsage(FMOD_DSP *dsp, unsigned int *exclusive, unsigned int *inclusive)
     * }
     */
    public static FunctionDescriptor FMOD_DSP_GetCPUUsage$descriptor() {
        return FMOD_DSP_GetCPUUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetCPUUsage(FMOD_DSP *dsp, unsigned int *exclusive, unsigned int *inclusive)
     * }
     */
    public static MethodHandle FMOD_DSP_GetCPUUsage$handle() {
        return FMOD_DSP_GetCPUUsage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetCPUUsage(FMOD_DSP *dsp, unsigned int *exclusive, unsigned int *inclusive)
     * }
     */
    public static MemorySegment FMOD_DSP_GetCPUUsage$address() {
        return FMOD_DSP_GetCPUUsage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSP_GetCPUUsage(FMOD_DSP *dsp, unsigned int *exclusive, unsigned int *inclusive)
     * }
     */
    public static int FMOD_DSP_GetCPUUsage(MemorySegment dsp, MemorySegment exclusive, MemorySegment inclusive) {
        var mh$ = FMOD_DSP_GetCPUUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSP_GetCPUUsage", dsp, exclusive, inclusive);
            }
            return (int)mh$.invokeExact(dsp, exclusive, inclusive);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_GetInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_GetInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetInput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **input)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_GetInput$descriptor() {
        return FMOD_DSPConnection_GetInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetInput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **input)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_GetInput$handle() {
        return FMOD_DSPConnection_GetInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetInput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **input)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_GetInput$address() {
        return FMOD_DSPConnection_GetInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetInput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **input)
     * }
     */
    public static int FMOD_DSPConnection_GetInput(MemorySegment dspconnection, MemorySegment input) {
        var mh$ = FMOD_DSPConnection_GetInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_GetInput", dspconnection, input);
            }
            return (int)mh$.invokeExact(dspconnection, input);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_GetOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_GetOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetOutput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **output)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_GetOutput$descriptor() {
        return FMOD_DSPConnection_GetOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetOutput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **output)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_GetOutput$handle() {
        return FMOD_DSPConnection_GetOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetOutput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **output)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_GetOutput$address() {
        return FMOD_DSPConnection_GetOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetOutput(FMOD_DSPCONNECTION *dspconnection, FMOD_DSP **output)
     * }
     */
    public static int FMOD_DSPConnection_GetOutput(MemorySegment dspconnection, MemorySegment output) {
        var mh$ = FMOD_DSPConnection_GetOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_GetOutput", dspconnection, output);
            }
            return (int)mh$.invokeExact(dspconnection, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_SetMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_SetMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMix(FMOD_DSPCONNECTION *dspconnection, float volume)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_SetMix$descriptor() {
        return FMOD_DSPConnection_SetMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMix(FMOD_DSPCONNECTION *dspconnection, float volume)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_SetMix$handle() {
        return FMOD_DSPConnection_SetMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMix(FMOD_DSPCONNECTION *dspconnection, float volume)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_SetMix$address() {
        return FMOD_DSPConnection_SetMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMix(FMOD_DSPCONNECTION *dspconnection, float volume)
     * }
     */
    public static int FMOD_DSPConnection_SetMix(MemorySegment dspconnection, float volume) {
        var mh$ = FMOD_DSPConnection_SetMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_SetMix", dspconnection, volume);
            }
            return (int)mh$.invokeExact(dspconnection, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_GetMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_GetMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMix(FMOD_DSPCONNECTION *dspconnection, float *volume)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_GetMix$descriptor() {
        return FMOD_DSPConnection_GetMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMix(FMOD_DSPCONNECTION *dspconnection, float *volume)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_GetMix$handle() {
        return FMOD_DSPConnection_GetMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMix(FMOD_DSPCONNECTION *dspconnection, float *volume)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_GetMix$address() {
        return FMOD_DSPConnection_GetMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMix(FMOD_DSPCONNECTION *dspconnection, float *volume)
     * }
     */
    public static int FMOD_DSPConnection_GetMix(MemorySegment dspconnection, MemorySegment volume) {
        var mh$ = FMOD_DSPConnection_GetMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_GetMix", dspconnection, volume);
            }
            return (int)mh$.invokeExact(dspconnection, volume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_SetMixMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_SetMixMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_SetMixMatrix$descriptor() {
        return FMOD_DSPConnection_SetMixMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_SetMixMatrix$handle() {
        return FMOD_DSPConnection_SetMixMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_SetMixMatrix$address() {
        return FMOD_DSPConnection_SetMixMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int outchannels, int inchannels, int inchannel_hop)
     * }
     */
    public static int FMOD_DSPConnection_SetMixMatrix(MemorySegment dspconnection, MemorySegment matrix, int outchannels, int inchannels, int inchannel_hop) {
        var mh$ = FMOD_DSPConnection_SetMixMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_SetMixMatrix", dspconnection, matrix, outchannels, inchannels, inchannel_hop);
            }
            return (int)mh$.invokeExact(dspconnection, matrix, outchannels, inchannels, inchannel_hop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_GetMixMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_GetMixMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_GetMixMatrix$descriptor() {
        return FMOD_DSPConnection_GetMixMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_GetMixMatrix$handle() {
        return FMOD_DSPConnection_GetMixMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_GetMixMatrix$address() {
        return FMOD_DSPConnection_GetMixMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetMixMatrix(FMOD_DSPCONNECTION *dspconnection, float *matrix, int *outchannels, int *inchannels, int inchannel_hop)
     * }
     */
    public static int FMOD_DSPConnection_GetMixMatrix(MemorySegment dspconnection, MemorySegment matrix, MemorySegment outchannels, MemorySegment inchannels, int inchannel_hop) {
        var mh$ = FMOD_DSPConnection_GetMixMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_GetMixMatrix", dspconnection, matrix, outchannels, inchannels, inchannel_hop);
            }
            return (int)mh$.invokeExact(dspconnection, matrix, outchannels, inchannels, inchannel_hop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_GetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_GetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetType(FMOD_DSPCONNECTION *dspconnection, FMOD_DSPCONNECTION_TYPE *type)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_GetType$descriptor() {
        return FMOD_DSPConnection_GetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetType(FMOD_DSPCONNECTION *dspconnection, FMOD_DSPCONNECTION_TYPE *type)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_GetType$handle() {
        return FMOD_DSPConnection_GetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetType(FMOD_DSPCONNECTION *dspconnection, FMOD_DSPCONNECTION_TYPE *type)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_GetType$address() {
        return FMOD_DSPConnection_GetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetType(FMOD_DSPCONNECTION *dspconnection, FMOD_DSPCONNECTION_TYPE *type)
     * }
     */
    public static int FMOD_DSPConnection_GetType(MemorySegment dspconnection, MemorySegment type) {
        var mh$ = FMOD_DSPConnection_GetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_GetType", dspconnection, type);
            }
            return (int)mh$.invokeExact(dspconnection, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetUserData(FMOD_DSPCONNECTION *dspconnection, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_SetUserData$descriptor() {
        return FMOD_DSPConnection_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetUserData(FMOD_DSPCONNECTION *dspconnection, void *userdata)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_SetUserData$handle() {
        return FMOD_DSPConnection_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetUserData(FMOD_DSPCONNECTION *dspconnection, void *userdata)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_SetUserData$address() {
        return FMOD_DSPConnection_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_SetUserData(FMOD_DSPCONNECTION *dspconnection, void *userdata)
     * }
     */
    public static int FMOD_DSPConnection_SetUserData(MemorySegment dspconnection, MemorySegment userdata) {
        var mh$ = FMOD_DSPConnection_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_SetUserData", dspconnection, userdata);
            }
            return (int)mh$.invokeExact(dspconnection, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_DSPConnection_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_DSPConnection_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetUserData(FMOD_DSPCONNECTION *dspconnection, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_DSPConnection_GetUserData$descriptor() {
        return FMOD_DSPConnection_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetUserData(FMOD_DSPCONNECTION *dspconnection, void **userdata)
     * }
     */
    public static MethodHandle FMOD_DSPConnection_GetUserData$handle() {
        return FMOD_DSPConnection_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetUserData(FMOD_DSPCONNECTION *dspconnection, void **userdata)
     * }
     */
    public static MemorySegment FMOD_DSPConnection_GetUserData$address() {
        return FMOD_DSPConnection_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_DSPConnection_GetUserData(FMOD_DSPCONNECTION *dspconnection, void **userdata)
     * }
     */
    public static int FMOD_DSPConnection_GetUserData(MemorySegment dspconnection, MemorySegment userdata) {
        var mh$ = FMOD_DSPConnection_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_DSPConnection_GetUserData", dspconnection, userdata);
            }
            return (int)mh$.invokeExact(dspconnection, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Release(FMOD_GEOMETRY *geometry)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_Release$descriptor() {
        return FMOD_Geometry_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Release(FMOD_GEOMETRY *geometry)
     * }
     */
    public static MethodHandle FMOD_Geometry_Release$handle() {
        return FMOD_Geometry_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Release(FMOD_GEOMETRY *geometry)
     * }
     */
    public static MemorySegment FMOD_Geometry_Release$address() {
        return FMOD_Geometry_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Release(FMOD_GEOMETRY *geometry)
     * }
     */
    public static int FMOD_Geometry_Release(MemorySegment geometry) {
        var mh$ = FMOD_Geometry_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_Release", geometry);
            }
            return (int)mh$.invokeExact(geometry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_AddPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_AddPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_AddPolygon(FMOD_GEOMETRY *geometry, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided, int numvertices, const FMOD_VECTOR *vertices, int *polygonindex)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_AddPolygon$descriptor() {
        return FMOD_Geometry_AddPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_AddPolygon(FMOD_GEOMETRY *geometry, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided, int numvertices, const FMOD_VECTOR *vertices, int *polygonindex)
     * }
     */
    public static MethodHandle FMOD_Geometry_AddPolygon$handle() {
        return FMOD_Geometry_AddPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_AddPolygon(FMOD_GEOMETRY *geometry, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided, int numvertices, const FMOD_VECTOR *vertices, int *polygonindex)
     * }
     */
    public static MemorySegment FMOD_Geometry_AddPolygon$address() {
        return FMOD_Geometry_AddPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_AddPolygon(FMOD_GEOMETRY *geometry, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided, int numvertices, const FMOD_VECTOR *vertices, int *polygonindex)
     * }
     */
    public static int FMOD_Geometry_AddPolygon(MemorySegment geometry, float directocclusion, float reverbocclusion, int doublesided, int numvertices, MemorySegment vertices, MemorySegment polygonindex) {
        var mh$ = FMOD_Geometry_AddPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_AddPolygon", geometry, directocclusion, reverbocclusion, doublesided, numvertices, vertices, polygonindex);
            }
            return (int)mh$.invokeExact(geometry, directocclusion, reverbocclusion, doublesided, numvertices, vertices, polygonindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetNumPolygons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetNumPolygons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetNumPolygons(FMOD_GEOMETRY *geometry, int *numpolygons)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetNumPolygons$descriptor() {
        return FMOD_Geometry_GetNumPolygons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetNumPolygons(FMOD_GEOMETRY *geometry, int *numpolygons)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetNumPolygons$handle() {
        return FMOD_Geometry_GetNumPolygons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetNumPolygons(FMOD_GEOMETRY *geometry, int *numpolygons)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetNumPolygons$address() {
        return FMOD_Geometry_GetNumPolygons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetNumPolygons(FMOD_GEOMETRY *geometry, int *numpolygons)
     * }
     */
    public static int FMOD_Geometry_GetNumPolygons(MemorySegment geometry, MemorySegment numpolygons) {
        var mh$ = FMOD_Geometry_GetNumPolygons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetNumPolygons", geometry, numpolygons);
            }
            return (int)mh$.invokeExact(geometry, numpolygons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetMaxPolygons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetMaxPolygons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetMaxPolygons(FMOD_GEOMETRY *geometry, int *maxpolygons, int *maxvertices)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetMaxPolygons$descriptor() {
        return FMOD_Geometry_GetMaxPolygons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetMaxPolygons(FMOD_GEOMETRY *geometry, int *maxpolygons, int *maxvertices)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetMaxPolygons$handle() {
        return FMOD_Geometry_GetMaxPolygons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetMaxPolygons(FMOD_GEOMETRY *geometry, int *maxpolygons, int *maxvertices)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetMaxPolygons$address() {
        return FMOD_Geometry_GetMaxPolygons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetMaxPolygons(FMOD_GEOMETRY *geometry, int *maxpolygons, int *maxvertices)
     * }
     */
    public static int FMOD_Geometry_GetMaxPolygons(MemorySegment geometry, MemorySegment maxpolygons, MemorySegment maxvertices) {
        var mh$ = FMOD_Geometry_GetMaxPolygons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetMaxPolygons", geometry, maxpolygons, maxvertices);
            }
            return (int)mh$.invokeExact(geometry, maxpolygons, maxvertices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetPolygonNumVertices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetPolygonNumVertices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonNumVertices(FMOD_GEOMETRY *geometry, int index, int *numvertices)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetPolygonNumVertices$descriptor() {
        return FMOD_Geometry_GetPolygonNumVertices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonNumVertices(FMOD_GEOMETRY *geometry, int index, int *numvertices)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetPolygonNumVertices$handle() {
        return FMOD_Geometry_GetPolygonNumVertices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonNumVertices(FMOD_GEOMETRY *geometry, int index, int *numvertices)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetPolygonNumVertices$address() {
        return FMOD_Geometry_GetPolygonNumVertices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonNumVertices(FMOD_GEOMETRY *geometry, int index, int *numvertices)
     * }
     */
    public static int FMOD_Geometry_GetPolygonNumVertices(MemorySegment geometry, int index, MemorySegment numvertices) {
        var mh$ = FMOD_Geometry_GetPolygonNumVertices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetPolygonNumVertices", geometry, index, numvertices);
            }
            return (int)mh$.invokeExact(geometry, index, numvertices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetPolygonVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetPolygonVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, const FMOD_VECTOR *vertex)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetPolygonVertex$descriptor() {
        return FMOD_Geometry_SetPolygonVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, const FMOD_VECTOR *vertex)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetPolygonVertex$handle() {
        return FMOD_Geometry_SetPolygonVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, const FMOD_VECTOR *vertex)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetPolygonVertex$address() {
        return FMOD_Geometry_SetPolygonVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, const FMOD_VECTOR *vertex)
     * }
     */
    public static int FMOD_Geometry_SetPolygonVertex(MemorySegment geometry, int index, int vertexindex, MemorySegment vertex) {
        var mh$ = FMOD_Geometry_SetPolygonVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetPolygonVertex", geometry, index, vertexindex, vertex);
            }
            return (int)mh$.invokeExact(geometry, index, vertexindex, vertex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetPolygonVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetPolygonVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, FMOD_VECTOR *vertex)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetPolygonVertex$descriptor() {
        return FMOD_Geometry_GetPolygonVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, FMOD_VECTOR *vertex)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetPolygonVertex$handle() {
        return FMOD_Geometry_GetPolygonVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, FMOD_VECTOR *vertex)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetPolygonVertex$address() {
        return FMOD_Geometry_GetPolygonVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonVertex(FMOD_GEOMETRY *geometry, int index, int vertexindex, FMOD_VECTOR *vertex)
     * }
     */
    public static int FMOD_Geometry_GetPolygonVertex(MemorySegment geometry, int index, int vertexindex, MemorySegment vertex) {
        var mh$ = FMOD_Geometry_GetPolygonVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetPolygonVertex", geometry, index, vertexindex, vertex);
            }
            return (int)mh$.invokeExact(geometry, index, vertexindex, vertex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetPolygonAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetPolygonAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetPolygonAttributes$descriptor() {
        return FMOD_Geometry_SetPolygonAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetPolygonAttributes$handle() {
        return FMOD_Geometry_SetPolygonAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetPolygonAttributes$address() {
        return FMOD_Geometry_SetPolygonAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float directocclusion, float reverbocclusion, FMOD_BOOL doublesided)
     * }
     */
    public static int FMOD_Geometry_SetPolygonAttributes(MemorySegment geometry, int index, float directocclusion, float reverbocclusion, int doublesided) {
        var mh$ = FMOD_Geometry_SetPolygonAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetPolygonAttributes", geometry, index, directocclusion, reverbocclusion, doublesided);
            }
            return (int)mh$.invokeExact(geometry, index, directocclusion, reverbocclusion, doublesided);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetPolygonAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetPolygonAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float *directocclusion, float *reverbocclusion, FMOD_BOOL *doublesided)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetPolygonAttributes$descriptor() {
        return FMOD_Geometry_GetPolygonAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float *directocclusion, float *reverbocclusion, FMOD_BOOL *doublesided)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetPolygonAttributes$handle() {
        return FMOD_Geometry_GetPolygonAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float *directocclusion, float *reverbocclusion, FMOD_BOOL *doublesided)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetPolygonAttributes$address() {
        return FMOD_Geometry_GetPolygonAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPolygonAttributes(FMOD_GEOMETRY *geometry, int index, float *directocclusion, float *reverbocclusion, FMOD_BOOL *doublesided)
     * }
     */
    public static int FMOD_Geometry_GetPolygonAttributes(MemorySegment geometry, int index, MemorySegment directocclusion, MemorySegment reverbocclusion, MemorySegment doublesided) {
        var mh$ = FMOD_Geometry_GetPolygonAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetPolygonAttributes", geometry, index, directocclusion, reverbocclusion, doublesided);
            }
            return (int)mh$.invokeExact(geometry, index, directocclusion, reverbocclusion, doublesided);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL active)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetActive$descriptor() {
        return FMOD_Geometry_SetActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL active)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetActive$handle() {
        return FMOD_Geometry_SetActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL active)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetActive$address() {
        return FMOD_Geometry_SetActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL active)
     * }
     */
    public static int FMOD_Geometry_SetActive(MemorySegment geometry, int active) {
        var mh$ = FMOD_Geometry_SetActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetActive", geometry, active);
            }
            return (int)mh$.invokeExact(geometry, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL *active)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetActive$descriptor() {
        return FMOD_Geometry_GetActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL *active)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetActive$handle() {
        return FMOD_Geometry_GetActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL *active)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetActive$address() {
        return FMOD_Geometry_GetActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetActive(FMOD_GEOMETRY *geometry, FMOD_BOOL *active)
     * }
     */
    public static int FMOD_Geometry_GetActive(MemorySegment geometry, MemorySegment active) {
        var mh$ = FMOD_Geometry_GetActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetActive", geometry, active);
            }
            return (int)mh$.invokeExact(geometry, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetRotation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetRotation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetRotation(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *forward, const FMOD_VECTOR *up)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetRotation$descriptor() {
        return FMOD_Geometry_SetRotation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetRotation(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *forward, const FMOD_VECTOR *up)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetRotation$handle() {
        return FMOD_Geometry_SetRotation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetRotation(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *forward, const FMOD_VECTOR *up)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetRotation$address() {
        return FMOD_Geometry_SetRotation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetRotation(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *forward, const FMOD_VECTOR *up)
     * }
     */
    public static int FMOD_Geometry_SetRotation(MemorySegment geometry, MemorySegment forward, MemorySegment up) {
        var mh$ = FMOD_Geometry_SetRotation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetRotation", geometry, forward, up);
            }
            return (int)mh$.invokeExact(geometry, forward, up);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetRotation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetRotation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetRotation(FMOD_GEOMETRY *geometry, FMOD_VECTOR *forward, FMOD_VECTOR *up)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetRotation$descriptor() {
        return FMOD_Geometry_GetRotation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetRotation(FMOD_GEOMETRY *geometry, FMOD_VECTOR *forward, FMOD_VECTOR *up)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetRotation$handle() {
        return FMOD_Geometry_GetRotation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetRotation(FMOD_GEOMETRY *geometry, FMOD_VECTOR *forward, FMOD_VECTOR *up)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetRotation$address() {
        return FMOD_Geometry_GetRotation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetRotation(FMOD_GEOMETRY *geometry, FMOD_VECTOR *forward, FMOD_VECTOR *up)
     * }
     */
    public static int FMOD_Geometry_GetRotation(MemorySegment geometry, MemorySegment forward, MemorySegment up) {
        var mh$ = FMOD_Geometry_GetRotation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetRotation", geometry, forward, up);
            }
            return (int)mh$.invokeExact(geometry, forward, up);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPosition(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *position)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetPosition$descriptor() {
        return FMOD_Geometry_SetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPosition(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *position)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetPosition$handle() {
        return FMOD_Geometry_SetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPosition(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *position)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetPosition$address() {
        return FMOD_Geometry_SetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetPosition(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *position)
     * }
     */
    public static int FMOD_Geometry_SetPosition(MemorySegment geometry, MemorySegment position) {
        var mh$ = FMOD_Geometry_SetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetPosition", geometry, position);
            }
            return (int)mh$.invokeExact(geometry, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPosition(FMOD_GEOMETRY *geometry, FMOD_VECTOR *position)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetPosition$descriptor() {
        return FMOD_Geometry_GetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPosition(FMOD_GEOMETRY *geometry, FMOD_VECTOR *position)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetPosition$handle() {
        return FMOD_Geometry_GetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPosition(FMOD_GEOMETRY *geometry, FMOD_VECTOR *position)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetPosition$address() {
        return FMOD_Geometry_GetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetPosition(FMOD_GEOMETRY *geometry, FMOD_VECTOR *position)
     * }
     */
    public static int FMOD_Geometry_GetPosition(MemorySegment geometry, MemorySegment position) {
        var mh$ = FMOD_Geometry_GetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetPosition", geometry, position);
            }
            return (int)mh$.invokeExact(geometry, position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetScale(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *scale)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetScale$descriptor() {
        return FMOD_Geometry_SetScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetScale(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *scale)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetScale$handle() {
        return FMOD_Geometry_SetScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetScale(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *scale)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetScale$address() {
        return FMOD_Geometry_SetScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetScale(FMOD_GEOMETRY *geometry, const FMOD_VECTOR *scale)
     * }
     */
    public static int FMOD_Geometry_SetScale(MemorySegment geometry, MemorySegment scale) {
        var mh$ = FMOD_Geometry_SetScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetScale", geometry, scale);
            }
            return (int)mh$.invokeExact(geometry, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetScale(FMOD_GEOMETRY *geometry, FMOD_VECTOR *scale)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetScale$descriptor() {
        return FMOD_Geometry_GetScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetScale(FMOD_GEOMETRY *geometry, FMOD_VECTOR *scale)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetScale$handle() {
        return FMOD_Geometry_GetScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetScale(FMOD_GEOMETRY *geometry, FMOD_VECTOR *scale)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetScale$address() {
        return FMOD_Geometry_GetScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetScale(FMOD_GEOMETRY *geometry, FMOD_VECTOR *scale)
     * }
     */
    public static int FMOD_Geometry_GetScale(MemorySegment geometry, MemorySegment scale) {
        var mh$ = FMOD_Geometry_GetScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetScale", geometry, scale);
            }
            return (int)mh$.invokeExact(geometry, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_Save {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_Save");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Save(FMOD_GEOMETRY *geometry, void *data, int *datasize)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_Save$descriptor() {
        return FMOD_Geometry_Save.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Save(FMOD_GEOMETRY *geometry, void *data, int *datasize)
     * }
     */
    public static MethodHandle FMOD_Geometry_Save$handle() {
        return FMOD_Geometry_Save.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Save(FMOD_GEOMETRY *geometry, void *data, int *datasize)
     * }
     */
    public static MemorySegment FMOD_Geometry_Save$address() {
        return FMOD_Geometry_Save.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_Save(FMOD_GEOMETRY *geometry, void *data, int *datasize)
     * }
     */
    public static int FMOD_Geometry_Save(MemorySegment geometry, MemorySegment data, MemorySegment datasize) {
        var mh$ = FMOD_Geometry_Save.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_Save", geometry, data, datasize);
            }
            return (int)mh$.invokeExact(geometry, data, datasize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetUserData(FMOD_GEOMETRY *geometry, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_SetUserData$descriptor() {
        return FMOD_Geometry_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetUserData(FMOD_GEOMETRY *geometry, void *userdata)
     * }
     */
    public static MethodHandle FMOD_Geometry_SetUserData$handle() {
        return FMOD_Geometry_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetUserData(FMOD_GEOMETRY *geometry, void *userdata)
     * }
     */
    public static MemorySegment FMOD_Geometry_SetUserData$address() {
        return FMOD_Geometry_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_SetUserData(FMOD_GEOMETRY *geometry, void *userdata)
     * }
     */
    public static int FMOD_Geometry_SetUserData(MemorySegment geometry, MemorySegment userdata) {
        var mh$ = FMOD_Geometry_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_SetUserData", geometry, userdata);
            }
            return (int)mh$.invokeExact(geometry, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Geometry_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Geometry_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetUserData(FMOD_GEOMETRY *geometry, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_Geometry_GetUserData$descriptor() {
        return FMOD_Geometry_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetUserData(FMOD_GEOMETRY *geometry, void **userdata)
     * }
     */
    public static MethodHandle FMOD_Geometry_GetUserData$handle() {
        return FMOD_Geometry_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetUserData(FMOD_GEOMETRY *geometry, void **userdata)
     * }
     */
    public static MemorySegment FMOD_Geometry_GetUserData$address() {
        return FMOD_Geometry_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Geometry_GetUserData(FMOD_GEOMETRY *geometry, void **userdata)
     * }
     */
    public static int FMOD_Geometry_GetUserData(MemorySegment geometry, MemorySegment userdata) {
        var mh$ = FMOD_Geometry_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Geometry_GetUserData", geometry, userdata);
            }
            return (int)mh$.invokeExact(geometry, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Release(FMOD_REVERB3D *reverb3d)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_Release$descriptor() {
        return FMOD_Reverb3D_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Release(FMOD_REVERB3D *reverb3d)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_Release$handle() {
        return FMOD_Reverb3D_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Release(FMOD_REVERB3D *reverb3d)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_Release$address() {
        return FMOD_Reverb3D_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Release(FMOD_REVERB3D *reverb3d)
     * }
     */
    public static int FMOD_Reverb3D_Release(MemorySegment reverb3d) {
        var mh$ = FMOD_Reverb3D_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_Release", reverb3d);
            }
            return (int)mh$.invokeExact(reverb3d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_Set3DAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_FLOAT,
            FmodCore.C_FLOAT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_Set3DAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Set3DAttributes(FMOD_REVERB3D *reverb3d, const FMOD_VECTOR *position, float mindistance, float maxdistance)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_Set3DAttributes$descriptor() {
        return FMOD_Reverb3D_Set3DAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Set3DAttributes(FMOD_REVERB3D *reverb3d, const FMOD_VECTOR *position, float mindistance, float maxdistance)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_Set3DAttributes$handle() {
        return FMOD_Reverb3D_Set3DAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Set3DAttributes(FMOD_REVERB3D *reverb3d, const FMOD_VECTOR *position, float mindistance, float maxdistance)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_Set3DAttributes$address() {
        return FMOD_Reverb3D_Set3DAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Set3DAttributes(FMOD_REVERB3D *reverb3d, const FMOD_VECTOR *position, float mindistance, float maxdistance)
     * }
     */
    public static int FMOD_Reverb3D_Set3DAttributes(MemorySegment reverb3d, MemorySegment position, float mindistance, float maxdistance) {
        var mh$ = FMOD_Reverb3D_Set3DAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_Set3DAttributes", reverb3d, position, mindistance, maxdistance);
            }
            return (int)mh$.invokeExact(reverb3d, position, mindistance, maxdistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_Get3DAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_Get3DAttributes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Get3DAttributes(FMOD_REVERB3D *reverb3d, FMOD_VECTOR *position, float *mindistance, float *maxdistance)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_Get3DAttributes$descriptor() {
        return FMOD_Reverb3D_Get3DAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Get3DAttributes(FMOD_REVERB3D *reverb3d, FMOD_VECTOR *position, float *mindistance, float *maxdistance)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_Get3DAttributes$handle() {
        return FMOD_Reverb3D_Get3DAttributes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Get3DAttributes(FMOD_REVERB3D *reverb3d, FMOD_VECTOR *position, float *mindistance, float *maxdistance)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_Get3DAttributes$address() {
        return FMOD_Reverb3D_Get3DAttributes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_Get3DAttributes(FMOD_REVERB3D *reverb3d, FMOD_VECTOR *position, float *mindistance, float *maxdistance)
     * }
     */
    public static int FMOD_Reverb3D_Get3DAttributes(MemorySegment reverb3d, MemorySegment position, MemorySegment mindistance, MemorySegment maxdistance) {
        var mh$ = FMOD_Reverb3D_Get3DAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_Get3DAttributes", reverb3d, position, mindistance, maxdistance);
            }
            return (int)mh$.invokeExact(reverb3d, position, mindistance, maxdistance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_SetProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_SetProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetProperties(FMOD_REVERB3D *reverb3d, const FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_SetProperties$descriptor() {
        return FMOD_Reverb3D_SetProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetProperties(FMOD_REVERB3D *reverb3d, const FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_SetProperties$handle() {
        return FMOD_Reverb3D_SetProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetProperties(FMOD_REVERB3D *reverb3d, const FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_SetProperties$address() {
        return FMOD_Reverb3D_SetProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetProperties(FMOD_REVERB3D *reverb3d, const FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static int FMOD_Reverb3D_SetProperties(MemorySegment reverb3d, MemorySegment properties) {
        var mh$ = FMOD_Reverb3D_SetProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_SetProperties", reverb3d, properties);
            }
            return (int)mh$.invokeExact(reverb3d, properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_GetProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_GetProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetProperties(FMOD_REVERB3D *reverb3d, FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_GetProperties$descriptor() {
        return FMOD_Reverb3D_GetProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetProperties(FMOD_REVERB3D *reverb3d, FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_GetProperties$handle() {
        return FMOD_Reverb3D_GetProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetProperties(FMOD_REVERB3D *reverb3d, FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_GetProperties$address() {
        return FMOD_Reverb3D_GetProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetProperties(FMOD_REVERB3D *reverb3d, FMOD_REVERB_PROPERTIES *properties)
     * }
     */
    public static int FMOD_Reverb3D_GetProperties(MemorySegment reverb3d, MemorySegment properties) {
        var mh$ = FMOD_Reverb3D_GetProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_GetProperties", reverb3d, properties);
            }
            return (int)mh$.invokeExact(reverb3d, properties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_SetActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_INT
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_SetActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL active)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_SetActive$descriptor() {
        return FMOD_Reverb3D_SetActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL active)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_SetActive$handle() {
        return FMOD_Reverb3D_SetActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL active)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_SetActive$address() {
        return FMOD_Reverb3D_SetActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL active)
     * }
     */
    public static int FMOD_Reverb3D_SetActive(MemorySegment reverb3d, int active) {
        var mh$ = FMOD_Reverb3D_SetActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_SetActive", reverb3d, active);
            }
            return (int)mh$.invokeExact(reverb3d, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_GetActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_GetActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL *active)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_GetActive$descriptor() {
        return FMOD_Reverb3D_GetActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL *active)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_GetActive$handle() {
        return FMOD_Reverb3D_GetActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL *active)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_GetActive$address() {
        return FMOD_Reverb3D_GetActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetActive(FMOD_REVERB3D *reverb3d, FMOD_BOOL *active)
     * }
     */
    public static int FMOD_Reverb3D_GetActive(MemorySegment reverb3d, MemorySegment active) {
        var mh$ = FMOD_Reverb3D_GetActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_GetActive", reverb3d, active);
            }
            return (int)mh$.invokeExact(reverb3d, active);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_SetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_SetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetUserData(FMOD_REVERB3D *reverb3d, void *userdata)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_SetUserData$descriptor() {
        return FMOD_Reverb3D_SetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetUserData(FMOD_REVERB3D *reverb3d, void *userdata)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_SetUserData$handle() {
        return FMOD_Reverb3D_SetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetUserData(FMOD_REVERB3D *reverb3d, void *userdata)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_SetUserData$address() {
        return FMOD_Reverb3D_SetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_SetUserData(FMOD_REVERB3D *reverb3d, void *userdata)
     * }
     */
    public static int FMOD_Reverb3D_SetUserData(MemorySegment reverb3d, MemorySegment userdata) {
        var mh$ = FMOD_Reverb3D_SetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_SetUserData", reverb3d, userdata);
            }
            return (int)mh$.invokeExact(reverb3d, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FMOD_Reverb3D_GetUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FmodCore.C_INT,
            FmodCore.C_POINTER,
            FmodCore.C_POINTER
        );

        public static final MemorySegment ADDR = FmodCore.findOrThrow("FMOD_Reverb3D_GetUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetUserData(FMOD_REVERB3D *reverb3d, void **userdata)
     * }
     */
    public static FunctionDescriptor FMOD_Reverb3D_GetUserData$descriptor() {
        return FMOD_Reverb3D_GetUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetUserData(FMOD_REVERB3D *reverb3d, void **userdata)
     * }
     */
    public static MethodHandle FMOD_Reverb3D_GetUserData$handle() {
        return FMOD_Reverb3D_GetUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetUserData(FMOD_REVERB3D *reverb3d, void **userdata)
     * }
     */
    public static MemorySegment FMOD_Reverb3D_GetUserData$address() {
        return FMOD_Reverb3D_GetUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FMOD_RESULT FMOD_Reverb3D_GetUserData(FMOD_REVERB3D *reverb3d, void **userdata)
     * }
     */
    public static int FMOD_Reverb3D_GetUserData(MemorySegment reverb3d, MemorySegment userdata) {
        var mh$ = FMOD_Reverb3D_GetUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FMOD_Reverb3D_GetUserData", reverb3d, userdata);
            }
            return (int)mh$.invokeExact(reverb3d, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FMOD_MEMORY_ALL = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define FMOD_MEMORY_ALL 4294967295
     * }
     */
    public static int FMOD_MEMORY_ALL() {
        return FMOD_MEMORY_ALL;
    }
    private static final int FMOD_SYSTEM_CALLBACK_ALL = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define FMOD_SYSTEM_CALLBACK_ALL 4294967295
     * }
     */
    public static int FMOD_SYSTEM_CALLBACK_ALL() {
        return FMOD_SYSTEM_CALLBACK_ALL;
    }
    private static final int FMOD_VIRTUAL_PLAYFROMSTART = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define FMOD_VIRTUAL_PLAYFROMSTART 2147483648
     * }
     */
    public static int FMOD_VIRTUAL_PLAYFROMSTART() {
        return FMOD_VIRTUAL_PLAYFROMSTART;
    }
    private static final int FMOD_CHANNELMASK_MONO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_MONO 1
     * }
     */
    public static int FMOD_CHANNELMASK_MONO() {
        return FMOD_CHANNELMASK_MONO;
    }
    private static final int FMOD_CHANNELMASK_STEREO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_STEREO 3
     * }
     */
    public static int FMOD_CHANNELMASK_STEREO() {
        return FMOD_CHANNELMASK_STEREO;
    }
    private static final int FMOD_CHANNELMASK_LRC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_LRC 7
     * }
     */
    public static int FMOD_CHANNELMASK_LRC() {
        return FMOD_CHANNELMASK_LRC;
    }
    private static final int FMOD_CHANNELMASK_QUAD = (int)51L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_QUAD 51
     * }
     */
    public static int FMOD_CHANNELMASK_QUAD() {
        return FMOD_CHANNELMASK_QUAD;
    }
    private static final int FMOD_CHANNELMASK_SURROUND = (int)55L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_SURROUND 55
     * }
     */
    public static int FMOD_CHANNELMASK_SURROUND() {
        return FMOD_CHANNELMASK_SURROUND;
    }
    private static final int FMOD_CHANNELMASK_5POINT1 = (int)63L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_5POINT1 63
     * }
     */
    public static int FMOD_CHANNELMASK_5POINT1() {
        return FMOD_CHANNELMASK_5POINT1;
    }
    private static final int FMOD_CHANNELMASK_5POINT1_REARS = (int)207L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_5POINT1_REARS 207
     * }
     */
    public static int FMOD_CHANNELMASK_5POINT1_REARS() {
        return FMOD_CHANNELMASK_5POINT1_REARS;
    }
    private static final int FMOD_CHANNELMASK_7POINT0 = (int)247L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_7POINT0 247
     * }
     */
    public static int FMOD_CHANNELMASK_7POINT0() {
        return FMOD_CHANNELMASK_7POINT0;
    }
    private static final int FMOD_CHANNELMASK_7POINT1 = (int)255L;
    /**
     * {@snippet lang=c :
     * #define FMOD_CHANNELMASK_7POINT1 255
     * }
     */
    public static int FMOD_CHANNELMASK_7POINT1() {
        return FMOD_CHANNELMASK_7POINT1;
    }
    private static final long FMOD_PORT_INDEX_NONE = -1L;
    /**
     * {@snippet lang=c :
     * #define FMOD_PORT_INDEX_NONE -1
     * }
     */
    public static long FMOD_PORT_INDEX_NONE() {
        return FMOD_PORT_INDEX_NONE;
    }
    private static final int FMOD_THREAD_PRIORITY_PLATFORM_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_PLATFORM_MIN -32768
     * }
     */
    public static int FMOD_THREAD_PRIORITY_PLATFORM_MIN() {
        return FMOD_THREAD_PRIORITY_PLATFORM_MIN;
    }
    private static final int FMOD_THREAD_PRIORITY_PLATFORM_MAX = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_PLATFORM_MAX 32768
     * }
     */
    public static int FMOD_THREAD_PRIORITY_PLATFORM_MAX() {
        return FMOD_THREAD_PRIORITY_PLATFORM_MAX;
    }
    private static final int FMOD_THREAD_PRIORITY_DEFAULT = (int)-32769L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_DEFAULT -32769
     * }
     */
    public static int FMOD_THREAD_PRIORITY_DEFAULT() {
        return FMOD_THREAD_PRIORITY_DEFAULT;
    }
    private static final int FMOD_THREAD_PRIORITY_LOW = (int)-32770L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_LOW -32770
     * }
     */
    public static int FMOD_THREAD_PRIORITY_LOW() {
        return FMOD_THREAD_PRIORITY_LOW;
    }
    private static final int FMOD_THREAD_PRIORITY_MEDIUM = (int)-32771L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_MEDIUM -32771
     * }
     */
    public static int FMOD_THREAD_PRIORITY_MEDIUM() {
        return FMOD_THREAD_PRIORITY_MEDIUM;
    }
    private static final int FMOD_THREAD_PRIORITY_HIGH = (int)-32772L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_HIGH -32772
     * }
     */
    public static int FMOD_THREAD_PRIORITY_HIGH() {
        return FMOD_THREAD_PRIORITY_HIGH;
    }
    private static final int FMOD_THREAD_PRIORITY_VERY_HIGH = (int)-32773L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_VERY_HIGH -32773
     * }
     */
    public static int FMOD_THREAD_PRIORITY_VERY_HIGH() {
        return FMOD_THREAD_PRIORITY_VERY_HIGH;
    }
    private static final int FMOD_THREAD_PRIORITY_EXTREME = (int)-32774L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_EXTREME -32774
     * }
     */
    public static int FMOD_THREAD_PRIORITY_EXTREME() {
        return FMOD_THREAD_PRIORITY_EXTREME;
    }
    private static final int FMOD_THREAD_PRIORITY_CRITICAL = (int)-32775L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_CRITICAL -32775
     * }
     */
    public static int FMOD_THREAD_PRIORITY_CRITICAL() {
        return FMOD_THREAD_PRIORITY_CRITICAL;
    }
    private static final int FMOD_THREAD_PRIORITY_MIXER = (int)-32774L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_MIXER -32774
     * }
     */
    public static int FMOD_THREAD_PRIORITY_MIXER() {
        return FMOD_THREAD_PRIORITY_MIXER;
    }
    private static final int FMOD_THREAD_PRIORITY_FEEDER = (int)-32775L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_FEEDER -32775
     * }
     */
    public static int FMOD_THREAD_PRIORITY_FEEDER() {
        return FMOD_THREAD_PRIORITY_FEEDER;
    }
    private static final int FMOD_THREAD_PRIORITY_STREAM = (int)-32773L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_STREAM -32773
     * }
     */
    public static int FMOD_THREAD_PRIORITY_STREAM() {
        return FMOD_THREAD_PRIORITY_STREAM;
    }
    private static final int FMOD_THREAD_PRIORITY_FILE = (int)-32772L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_FILE -32772
     * }
     */
    public static int FMOD_THREAD_PRIORITY_FILE() {
        return FMOD_THREAD_PRIORITY_FILE;
    }
    private static final int FMOD_THREAD_PRIORITY_NONBLOCKING = (int)-32772L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_NONBLOCKING -32772
     * }
     */
    public static int FMOD_THREAD_PRIORITY_NONBLOCKING() {
        return FMOD_THREAD_PRIORITY_NONBLOCKING;
    }
    private static final int FMOD_THREAD_PRIORITY_RECORD = (int)-32772L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_RECORD -32772
     * }
     */
    public static int FMOD_THREAD_PRIORITY_RECORD() {
        return FMOD_THREAD_PRIORITY_RECORD;
    }
    private static final int FMOD_THREAD_PRIORITY_GEOMETRY = (int)-32770L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_GEOMETRY -32770
     * }
     */
    public static int FMOD_THREAD_PRIORITY_GEOMETRY() {
        return FMOD_THREAD_PRIORITY_GEOMETRY;
    }
    private static final int FMOD_THREAD_PRIORITY_PROFILER = (int)-32771L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_PROFILER -32771
     * }
     */
    public static int FMOD_THREAD_PRIORITY_PROFILER() {
        return FMOD_THREAD_PRIORITY_PROFILER;
    }
    private static final int FMOD_THREAD_PRIORITY_STUDIO_UPDATE = (int)-32771L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_STUDIO_UPDATE -32771
     * }
     */
    public static int FMOD_THREAD_PRIORITY_STUDIO_UPDATE() {
        return FMOD_THREAD_PRIORITY_STUDIO_UPDATE;
    }
    private static final int FMOD_THREAD_PRIORITY_STUDIO_LOAD_BANK = (int)-32771L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_STUDIO_LOAD_BANK -32771
     * }
     */
    public static int FMOD_THREAD_PRIORITY_STUDIO_LOAD_BANK() {
        return FMOD_THREAD_PRIORITY_STUDIO_LOAD_BANK;
    }
    private static final int FMOD_THREAD_PRIORITY_STUDIO_LOAD_SAMPLE = (int)-32771L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_STUDIO_LOAD_SAMPLE -32771
     * }
     */
    public static int FMOD_THREAD_PRIORITY_STUDIO_LOAD_SAMPLE() {
        return FMOD_THREAD_PRIORITY_STUDIO_LOAD_SAMPLE;
    }
    private static final int FMOD_THREAD_PRIORITY_CONVOLUTION1 = (int)-32773L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_CONVOLUTION1 -32773
     * }
     */
    public static int FMOD_THREAD_PRIORITY_CONVOLUTION1() {
        return FMOD_THREAD_PRIORITY_CONVOLUTION1;
    }
    private static final int FMOD_THREAD_PRIORITY_CONVOLUTION2 = (int)-32773L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_PRIORITY_CONVOLUTION2 -32773
     * }
     */
    public static int FMOD_THREAD_PRIORITY_CONVOLUTION2() {
        return FMOD_THREAD_PRIORITY_CONVOLUTION2;
    }
    private static final int FMOD_THREAD_STACK_SIZE_MIXER = (int)81920L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_MIXER 81920
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_MIXER() {
        return FMOD_THREAD_STACK_SIZE_MIXER;
    }
    private static final int FMOD_THREAD_STACK_SIZE_FEEDER = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_FEEDER 16384
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_FEEDER() {
        return FMOD_THREAD_STACK_SIZE_FEEDER;
    }
    private static final int FMOD_THREAD_STACK_SIZE_STREAM = (int)98304L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_STREAM 98304
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_STREAM() {
        return FMOD_THREAD_STACK_SIZE_STREAM;
    }
    private static final int FMOD_THREAD_STACK_SIZE_FILE = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_FILE 65536
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_FILE() {
        return FMOD_THREAD_STACK_SIZE_FILE;
    }
    private static final int FMOD_THREAD_STACK_SIZE_NONBLOCKING = (int)114688L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_NONBLOCKING 114688
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_NONBLOCKING() {
        return FMOD_THREAD_STACK_SIZE_NONBLOCKING;
    }
    private static final int FMOD_THREAD_STACK_SIZE_RECORD = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_RECORD 16384
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_RECORD() {
        return FMOD_THREAD_STACK_SIZE_RECORD;
    }
    private static final int FMOD_THREAD_STACK_SIZE_GEOMETRY = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_GEOMETRY 49152
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_GEOMETRY() {
        return FMOD_THREAD_STACK_SIZE_GEOMETRY;
    }
    private static final int FMOD_THREAD_STACK_SIZE_PROFILER = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_PROFILER 131072
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_PROFILER() {
        return FMOD_THREAD_STACK_SIZE_PROFILER;
    }
    private static final int FMOD_THREAD_STACK_SIZE_STUDIO_UPDATE = (int)98304L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_STUDIO_UPDATE 98304
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_STUDIO_UPDATE() {
        return FMOD_THREAD_STACK_SIZE_STUDIO_UPDATE;
    }
    private static final int FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_BANK = (int)98304L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_BANK 98304
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_BANK() {
        return FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_BANK;
    }
    private static final int FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_SAMPLE = (int)98304L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_SAMPLE 98304
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_SAMPLE() {
        return FMOD_THREAD_STACK_SIZE_STUDIO_LOAD_SAMPLE;
    }
    private static final int FMOD_THREAD_STACK_SIZE_CONVOLUTION1 = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_CONVOLUTION1 16384
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_CONVOLUTION1() {
        return FMOD_THREAD_STACK_SIZE_CONVOLUTION1;
    }
    private static final int FMOD_THREAD_STACK_SIZE_CONVOLUTION2 = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_STACK_SIZE_CONVOLUTION2 16384
     * }
     */
    public static int FMOD_THREAD_STACK_SIZE_CONVOLUTION2() {
        return FMOD_THREAD_STACK_SIZE_CONVOLUTION2;
    }
    private static final long FMOD_THREAD_AFFINITY_GROUP_DEFAULT = 4611686018427387904L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_GROUP_DEFAULT 4611686018427387904
     * }
     */
    public static long FMOD_THREAD_AFFINITY_GROUP_DEFAULT() {
        return FMOD_THREAD_AFFINITY_GROUP_DEFAULT;
    }
    private static final long FMOD_THREAD_AFFINITY_GROUP_A = 4611686018427387905L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_GROUP_A 4611686018427387905
     * }
     */
    public static long FMOD_THREAD_AFFINITY_GROUP_A() {
        return FMOD_THREAD_AFFINITY_GROUP_A;
    }
    private static final long FMOD_THREAD_AFFINITY_GROUP_B = 4611686018427387906L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_GROUP_B 4611686018427387906
     * }
     */
    public static long FMOD_THREAD_AFFINITY_GROUP_B() {
        return FMOD_THREAD_AFFINITY_GROUP_B;
    }
    private static final long FMOD_THREAD_AFFINITY_GROUP_C = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_GROUP_C 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_GROUP_C() {
        return FMOD_THREAD_AFFINITY_GROUP_C;
    }
    private static final long FMOD_THREAD_AFFINITY_MIXER = 4611686018427387905L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_MIXER 4611686018427387905
     * }
     */
    public static long FMOD_THREAD_AFFINITY_MIXER() {
        return FMOD_THREAD_AFFINITY_MIXER;
    }
    private static final long FMOD_THREAD_AFFINITY_FEEDER = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_FEEDER 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_FEEDER() {
        return FMOD_THREAD_AFFINITY_FEEDER;
    }
    private static final long FMOD_THREAD_AFFINITY_STREAM = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_STREAM 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_STREAM() {
        return FMOD_THREAD_AFFINITY_STREAM;
    }
    private static final long FMOD_THREAD_AFFINITY_FILE = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_FILE 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_FILE() {
        return FMOD_THREAD_AFFINITY_FILE;
    }
    private static final long FMOD_THREAD_AFFINITY_NONBLOCKING = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_NONBLOCKING 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_NONBLOCKING() {
        return FMOD_THREAD_AFFINITY_NONBLOCKING;
    }
    private static final long FMOD_THREAD_AFFINITY_RECORD = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_RECORD 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_RECORD() {
        return FMOD_THREAD_AFFINITY_RECORD;
    }
    private static final long FMOD_THREAD_AFFINITY_GEOMETRY = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_GEOMETRY 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_GEOMETRY() {
        return FMOD_THREAD_AFFINITY_GEOMETRY;
    }
    private static final long FMOD_THREAD_AFFINITY_PROFILER = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_PROFILER 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_PROFILER() {
        return FMOD_THREAD_AFFINITY_PROFILER;
    }
    private static final long FMOD_THREAD_AFFINITY_STUDIO_UPDATE = 4611686018427387906L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_STUDIO_UPDATE 4611686018427387906
     * }
     */
    public static long FMOD_THREAD_AFFINITY_STUDIO_UPDATE() {
        return FMOD_THREAD_AFFINITY_STUDIO_UPDATE;
    }
    private static final long FMOD_THREAD_AFFINITY_STUDIO_LOAD_BANK = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_STUDIO_LOAD_BANK 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_STUDIO_LOAD_BANK() {
        return FMOD_THREAD_AFFINITY_STUDIO_LOAD_BANK;
    }
    private static final long FMOD_THREAD_AFFINITY_STUDIO_LOAD_SAMPLE = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_STUDIO_LOAD_SAMPLE 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_STUDIO_LOAD_SAMPLE() {
        return FMOD_THREAD_AFFINITY_STUDIO_LOAD_SAMPLE;
    }
    private static final long FMOD_THREAD_AFFINITY_CONVOLUTION1 = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CONVOLUTION1 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_CONVOLUTION1() {
        return FMOD_THREAD_AFFINITY_CONVOLUTION1;
    }
    private static final long FMOD_THREAD_AFFINITY_CONVOLUTION2 = 4611686018427387907L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CONVOLUTION2 4611686018427387907
     * }
     */
    public static long FMOD_THREAD_AFFINITY_CONVOLUTION2() {
        return FMOD_THREAD_AFFINITY_CONVOLUTION2;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_0 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_0 1
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_0() {
        return FMOD_THREAD_AFFINITY_CORE_0;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_1 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_1 2
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_1() {
        return FMOD_THREAD_AFFINITY_CORE_1;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_2 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_2 4
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_2() {
        return FMOD_THREAD_AFFINITY_CORE_2;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_3 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_3 8
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_3() {
        return FMOD_THREAD_AFFINITY_CORE_3;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_4 = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_4 16
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_4() {
        return FMOD_THREAD_AFFINITY_CORE_4;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_5 = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_5 32
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_5() {
        return FMOD_THREAD_AFFINITY_CORE_5;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_6 = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_6 64
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_6() {
        return FMOD_THREAD_AFFINITY_CORE_6;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_7 = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_7 128
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_7() {
        return FMOD_THREAD_AFFINITY_CORE_7;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_8 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_8 256
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_8() {
        return FMOD_THREAD_AFFINITY_CORE_8;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_9 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_9 512
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_9() {
        return FMOD_THREAD_AFFINITY_CORE_9;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_10 = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_10 1024
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_10() {
        return FMOD_THREAD_AFFINITY_CORE_10;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_11 = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_11 2048
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_11() {
        return FMOD_THREAD_AFFINITY_CORE_11;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_12 = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_12 4096
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_12() {
        return FMOD_THREAD_AFFINITY_CORE_12;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_13 = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_13 8192
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_13() {
        return FMOD_THREAD_AFFINITY_CORE_13;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_14 = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_14 16384
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_14() {
        return FMOD_THREAD_AFFINITY_CORE_14;
    }
    private static final int FMOD_THREAD_AFFINITY_CORE_15 = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FMOD_THREAD_AFFINITY_CORE_15 32768
     * }
     */
    public static int FMOD_THREAD_AFFINITY_CORE_15() {
        return FMOD_THREAD_AFFINITY_CORE_15;
    }
}

